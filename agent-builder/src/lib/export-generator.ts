import { NodeData, EdgeData, COMPONENTS } from './types'

export function generateExport(projectName: string, description: string, nodes: NodeData[], edges: EdgeData[]) {
  const sorted = topologicalSort(nodes, edges)
  return {
    'skill.json': generateSkillJson(projectName, description, nodes, edges),
    'agent.py': generatePythonAgent(projectName, description, sorted, edges),
    'Dockerfile': generateDockerfile(projectName),
    'docker-compose.yml': generateDockerCompose(projectName),
    'config.json': JSON.stringify(generateConfig(projectName, description, nodes, edges), null, 2),
    'SOUL.md': generateSoulMd(projectName, description, nodes),
  }
}

function generateSkillJson(name: string, desc: string, nodes: NodeData[], edges: EdgeData[]) {
  const triggerNodes = nodes.filter(n => n.category === 'triggers')
  const integrationNodes = nodes.filter(n => n.category === 'integrations')
  const aiNodes = nodes.filter(n => n.category === 'ai')

  const skill = {
    name: name.toLowerCase().replace(/\s+/g, '-'),
    version: '1.0.0',
    description: desc || `AI agent: ${name}`,
    author: 'AgentForge',
    triggers: triggerNodes.map(n => {
      if (n.type === 'schedule') return { type: 'cron', expression: n.config.cron || '0 * * * *', timezone: n.config.timezone || 'UTC' }
      if (n.type === 'webhook') return { type: 'webhook', path: n.config.path || '/webhook', method: n.config.method || 'POST' }
      if (n.type === 'event') return { type: 'event', name: n.config.event_name || 'default' }
      return { type: 'manual' }
    }),
    tools: integrationNodes.map(n => ({ name: n.type, config: n.config })),
    models: aiNodes.map(n => ({ type: n.type, model: n.config.model || 'gpt-4o', temperature: n.config.temperature || 0.7 })),
    graph: {
      nodes: nodes.map(n => ({ id: n.id, type: n.type, category: n.category, config: n.config })),
      edges: edges.map(e => ({ from: e.source, to: e.target })),
    },
  }
  return JSON.stringify(skill, null, 2)
}

function generatePythonAgent(name: string, desc: string, sorted: NodeData[], edges: EdgeData[]) {
  const lines = [
    `#!/usr/bin/env python3`,
    `"""${name} - Generated by AgentForge"""`,
    ``,
    `import json, os, sys, asyncio, logging`,
    `from datetime import datetime`,
    ``,
    `logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(name)s] %(message)s')`,
    `logger = logging.getLogger("${name.replace(/[^a-zA-Z0-9]/g, '_')}")`,
    ``,
    ``,
    `class Agent:`,
    `    """${desc || name}"""`,
    ``,
    `    def __init__(self):`,
    `        self.name = "${name}"`,
    `        self.config = json.load(open("config.json")) if os.path.exists("config.json") else {}`,
    `        self.context = {}`,
    ``,
    `    async def run(self, input_data=None):`,
    `        """Execute the agent workflow."""`,
    `        logger.info(f"Starting {self.name}...")`,
    `        self.context = {"input": input_data, "results": {}, "timestamp": datetime.utcnow().isoformat()}`,
    ``,
  ]

  for (const node of sorted) {
    const safeName = node.type.replace(/[^a-z0-9]/g, '_')
    lines.push(`        # ${node.label} (${node.type})`)
    lines.push(`        try:`)
    lines.push(`            self.context["results"]["${node.id}"] = await self.step_${safeName}(self.context)`)
    lines.push(`            logger.info(f"âœ“ ${node.label} complete")`)
    lines.push(`        except Exception as e:`)
    lines.push(`            logger.error(f"âœ— ${node.label} failed: {e}")`)
    lines.push(`            self.context["results"]["${node.id}"] = {"error": str(e)}`)
    lines.push(``)
  }

  lines.push(`        logger.info(f"Workflow complete. {len(self.context['results'])} steps executed.")`)
  lines.push(`        return self.context`)
  lines.push(``)

  const types = Array.from(new Set(sorted.map(n => n.type)))
  for (const type of types) {
    const safeName = type.replace(/[^a-z0-9]/g, '_')
    const node = sorted.find(n => n.type === type)!
    lines.push(`    async def step_${safeName}(self, ctx):`)
    
    if (type === 'schedule') {
      lines.push(`        """Trigger: Schedule (${node.config.cron || 'manual'})"""`)
      lines.push(`        return {"triggered": True, "time": datetime.utcnow().isoformat()}`)
    } else if (type === 'call_api') {
      lines.push(`        """Call external API"""`)
      lines.push(`        import aiohttp`)
      lines.push(`        async with aiohttp.ClientSession() as session:`)
      lines.push(`            url = "${node.config.url || 'https://api.example.com'}"`)
      lines.push(`            async with session.${(node.config.method || 'GET').toLowerCase()}(url) as resp:`)
      lines.push(`                return await resp.json()`)
    } else if (type === 'llm_call') {
      lines.push(`        """Call LLM for AI processing"""`)
      lines.push(`        # Using OpenAI-compatible API`)
      lines.push(`        import openai`)
      lines.push(`        client = openai.AsyncOpenAI()`)
      lines.push(`        resp = await client.chat.completions.create(`)
      lines.push(`            model="${node.config.model || 'gpt-4o'}",`)
      lines.push(`            messages=[`)
      lines.push(`                {"role": "system", "content": """${(node.config.system_prompt || 'You are a helpful assistant.').replace(/"/g, '\\"')}"""},`)
      lines.push(`                {"role": "user", "content": str(ctx.get("input", ""))},`)
      lines.push(`            ],`)
      lines.push(`            temperature=${node.config.temperature || 0.7},`)
      lines.push(`        )`)
      lines.push(`        return {"text": resp.choices[0].message.content}`)
    } else if (type === 'send_message') {
      lines.push(`        """Send message via ${node.config.channel || 'channel'}"""`)
      lines.push(`        message = "${(node.config.message || 'Hello!').replace(/"/g, '\\"')}"`)
      lines.push(`        logger.info(f"Sending: {message}")`)
      lines.push(`        # TODO: Implement ${node.config.channel || 'channel'} integration`)
      lines.push(`        return {"sent": True, "channel": "${node.config.channel || 'default'}"}`)
    } else if (type === 'if_else') {
      lines.push(`        """Conditional: ${node.config.condition || 'check'}"""`)
      lines.push(`        # TODO: Implement condition logic`)
      lines.push(`        return {"condition": "${node.config.condition || 'true'}", "result": True}`)
    } else {
      lines.push(`        """${node.label}"""`)
      lines.push(`        # TODO: Implement ${type} logic`)
      lines.push(`        return {"status": "ok", "type": "${type}"}`)
    }
    lines.push(``)
  }

  lines.push(``)
  lines.push(`async def main():`)
  lines.push(`    agent = Agent()`)
  lines.push(`    result = await agent.run({"query": "test"})`)
  lines.push(`    print(json.dumps(result, indent=2, default=str))`)
  lines.push(``)
  lines.push(``)
  lines.push(`if __name__ == "__main__":`)
  lines.push(`    asyncio.run(main())`)

  return lines.join('\n')
}

function generateDockerfile(name: string) {
  return `FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV PYTHONUNBUFFERED=1
ENV AGENT_NAME="${name}"

CMD ["python", "agent.py"]
`
}

function generateDockerCompose(name: string) {
  const safeName = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')
  return `version: "3.8"

services:
  agent:
    build: .
    container_name: ${safeName}
    restart: unless-stopped
    env_file:
      - .env
    environment:
      - AGENT_NAME=${name}
    volumes:
      - ./data:/app/data
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
`
}

function generateConfig(name: string, desc: string, nodes: NodeData[], edges: EdgeData[]) {
  return {
    name,
    description: desc,
    version: '1.0.0',
    triggers: nodes.filter(n => n.category === 'triggers').map(n => ({ type: n.type, config: n.config })),
    tools: nodes.filter(n => ['actions', 'integrations'].includes(n.category)).map(n => ({ type: n.type, config: n.config })),
    ai: nodes.filter(n => n.category === 'ai').map(n => ({ type: n.type, config: n.config })),
    graph: {
      nodes: nodes.map(n => ({ id: n.id, type: n.type, category: n.category })),
      edges: edges.map(e => ({ from: e.source, to: e.target })),
    },
  }
}

function generateSoulMd(name: string, desc: string, nodes: NodeData[]) {
  const aiNodes = nodes.filter(n => n.category === 'ai')
  const systemPrompt = aiNodes.find(n => n.config?.system_prompt)?.config?.system_prompt || 'You are a helpful AI agent.'

  return `# ${name}

${desc || 'An AI agent built with AgentForge.'}

## Role
${systemPrompt}

## Capabilities
${nodes.map(n => `- **${n.label}** (${n.type})`).join('\n')}

## Workflow
${nodes.length > 0 ? 'This agent follows a ${nodes.length}-step workflow:' : 'No steps configured.'}
${nodes.map((n, i) => `${i + 1}. ${n.label}`).join('\n')}

## Behavior
- Process triggers and execute the defined workflow
- Follow the node graph logic for decision making
- Report results through configured integrations
`
}

function topologicalSort(nodes: NodeData[], edges: EdgeData[]): NodeData[] {
  const nodeMap = new Map(nodes.map(n => [n.id, n]))
  const inDegree = new Map(nodes.map(n => [n.id, 0]))
  for (const e of edges) {
    inDegree.set(e.target, (inDegree.get(e.target) || 0) + 1)
  }
  const queue = nodes.filter(n => (inDegree.get(n.id) || 0) === 0)
  const result: NodeData[] = []
  while (queue.length > 0) {
    const node = queue.shift()!
    result.push(node)
    for (const e of edges.filter(e => e.source === node.id)) {
      const deg = (inDegree.get(e.target) || 1) - 1
      inDegree.set(e.target, deg)
      if (deg === 0) {
        const t = nodeMap.get(e.target)
        if (t) queue.push(t)
      }
    }
  }
  for (const n of nodes) {
    if (!result.find(r => r.id === n.id)) result.push(n)
  }
  return result
}
