{
  "filename": "hyperliquid_bot_v2_optimized.py",
  "description": "Hyperliquid Scalping Bot V2.1 - Multi-timeframe trend following with learning layer",
  "version": "2.1",
  "updated": "2026-02-07",
  "config_summary": {
    "leverage": "8x default, 12x max",
    "take_profit": "0.375% price move = 3% position profit at 8x",
    "stop_loss": "0.2-0.4% price move = 1.6-3.2% position loss at 8x",
    "trailing_stop": "Activates at 0.5% price move (4% position profit), keeps 70% of peak",
    "strategies": [
      "Momentum",
      "Pullback",
      "Breakout",
      "VolumeSike",
      "WhaleMode"
    ],
    "features": [
      "MTF Trend Filter",
      "Learning Layer",
      "Orphan Detection",
      "Hard Trend Blocks"
    ]
  },
  "code": "#!/usr/bin/env python3\n\"\"\"\n\ud83d\ude80 HYPERLIQUID SCALPING BOT V2.1 - MULTI-TIMEFRAME TREND FOLLOWING \ud83d\ude80\n\nWHAT'S NEW IN V2.1:\n\u2705 Multi-timeframe trend analysis (5m, 15m, 30m, 1h)\n\u2705 HARD BLOCKS - Never trade against strong trends!\n\u2705 Trailing stops - Let winners run in trends!\n\u2705 Market regime detection - Adapt to conditions!\n\u2705 Trend scoring system (-100 to +100)\n\nCRITICAL FIX:\nThe bot was losing because it fought the trend. Now it ONLY trades WITH the trend.\n- Uptrend (score > 30): LONGS ONLY, NO SHORTS\n- Downtrend (score < -30): SHORTS ONLY, NO LONGS\n- Ranging (-30 to +30): Both directions allowed\n\nTARGET PERFORMANCE:\n- Win Rate: 70-75% (improved from 65-70%)\n- Daily P&L: $12-20 on $600 capital (improved from $8-12)\n- Risk: VERY LOW (trend-following = natural edge)\n\nBased on multi-timeframe analysis principles\n\"\"\"\n\nimport json\nimport time\nimport os\nimport sys\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple, Any\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport traceback\nimport statistics\n\nsys.stdout.reconfigure(line_buffering=True)\nsys.stderr.reconfigure(line_buffering=True)\n\nfrom hyperliquid.info import Info\nfrom hyperliquid.exchange import Exchange\nfrom eth_account import Account\n\n# Learning layer integration\ntry:\n    from hyperliquid_learning_layer import LearningLayerManager\n    LEARNING_ENABLED = True\nexcept ImportError:\n    LEARNING_ENABLED = False\n    print(\"\u26a0\ufe0f Learning layer not available\")\n\n\nclass TradeSide(Enum):\n    LONG = \"LONG\"\n    SHORT = \"SHORT\"\n\n\nclass SignalType(Enum):\n    MOMENTUM = \"MOMENTUM\"\n    PULLBACK = \"PULLBACK\"\n    BREAKOUT = \"BREAKOUT\"\n    VOLUME_SPIKE = \"VOLUME_SPIKE\"\n    WHALE_MODE = \"WHALE_MODE\"\n\n\nclass MarketTrend(Enum):\n    STRONG_UP = \"STRONG_UP\"\n    UP = \"UP\"\n    NEUTRAL = \"NEUTRAL\"\n    DOWN = \"DOWN\"\n    STRONG_DOWN = \"STRONG_DOWN\"\n\n\nclass MarketRegime(Enum):\n    \"\"\"Market regime based on multi-timeframe analysis\"\"\"\n    STRONG_TREND_UP = \"STRONG_TREND_UP\"\n    WEAK_TREND_UP = \"WEAK_TREND_UP\"\n    RANGING = \"RANGING\"\n    WEAK_TREND_DOWN = \"WEAK_TREND_DOWN\"\n    STRONG_TREND_DOWN = \"STRONG_TREND_DOWN\"\n\n\n@dataclass\nclass ScalpingSignal:\n    \"\"\"Trading signal with trend context\"\"\"\n    signal_type: SignalType\n    side: TradeSide\n    confidence: float\n    entry_price: float\n    stop_loss: float\n    take_profit: float\n    leverage: int\n    reasons: List[str] = field(default_factory=list)\n    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())\n    trend: Optional[str] = None\n    trend_score: Optional[float] = None\n    regime: Optional[str] = None\n    atr: Optional[float] = None\n    use_trailing_stop: bool = False\n    trailing_stop_distance: Optional[float] = None\n    highest_pnl: float = 0.0\n\n\n@dataclass\nclass RiskState:\n    \"\"\"Risk management state\"\"\"\n    daily_pnl: float = 0.0\n    daily_trades: int = 0\n    consecutive_losses: int = 0\n    peak_balance: float = 0.0\n    last_trade_time: Optional[str] = None\n    total_trades: int = 0\n    winning_trades: int = 0\n    losing_trades: int = 0\n    open_positions: Dict = field(default_factory=dict)\n    paused_until: Optional[str] = None\n    last_reset_date: str = field(default_factory=lambda: datetime.now().strftime(\"%Y-%m-%d\"))\n\n\nclass Config:\n    \"\"\"Optimized configuration\"\"\"\n    \n    # === RISK MANAGEMENT ===\n    MIN_POSITION_USD = 10.0\n    TARGET_POSITION_PCT = 0.04\n    MAX_POSITION_PCT = 0.08\n    MAX_POSITIONS = 2\n    DAILY_LOSS_LIMIT = 20.0\n    MAX_CONSECUTIVE_LOSSES = 3\n    PAUSE_DURATION_MINUTES = 60\n    MAX_DRAWDOWN_PCT = 20.0\n    MAX_DAILY_TRADES = 10\n    \n    # === LEVERAGE ===\n    DEFAULT_LEVERAGE = 8\n    MAX_LEVERAGE = 12\n    \n    # === SIGNAL THRESHOLDS ===\n    MIN_CONFIDENCE_MOMENTUM = 65\n    MIN_CONFIDENCE_PULLBACK = 70\n    MIN_CONFIDENCE_BREAKOUT = 68\n    MIN_CONFIDENCE_VOLUME = 65\n    MIN_CONFIDENCE_WHALE = 75\n    \n    # === STOPS & TARGETS (ATR-based) - HYBRID SCALP MODE ===\n    MOMENTUM_STOP_ATR = 1.2\n    MOMENTUM_TARGET_ATR = 1.5  # Quick scalps\n    \n    PULLBACK_STOP_ATR = 1.0\n    PULLBACK_TARGET_ATR = 2.0  # Faster exits\n    \n    BREAKOUT_STOP_ATR = 1.5\n    BREAKOUT_TARGET_ATR = 2.0  # Faster exits\n    \n    VOLUME_STOP_ATR = 1.2\n    VOLUME_TARGET_ATR = 1.5  # Quick scalps\n    \n    WHALE_STOP_ATR = 1.5\n    WHALE_TARGET_ATR = 2.5  # Give whales some room\n    \n    # === LEVERAGE-ADJUSTED STOPS (based on POSITION P&L, not price) ===\n    # Formula: desired_position_pct / leverage = price_move_pct\n    # At 8x leverage:\n    #   1.5% position loss = 0.1875% price move\n    #   2.5% position loss = 0.3125% price move\n    MIN_STOP_PCT = 0.002        # 0.2% price = 1.6% position loss at 8x\n    MAX_STOP_PCT = 0.004        # 0.4% price = 3.2% position loss at 8x\n    \n    # === SCALP MODE: FIXED PROFIT TARGETS (LEVERAGE-ADJUSTED) ===\n    # At 8x leverage:\n    #   3% position profit = 0.375% price move\n    #   1.5% position profit = 0.1875% price move\n    MAX_TARGET_PCT = 0.00375    # 0.375% price = 3% position profit at 8x\n    MIN_TARGET_PCT = 0.002      # 0.2% price = 1.6% position profit at 8x\n    \n    # === TRAILING STOPS (NEW!) ===\n    TRAILING_STOP_ACTIVATION_PCT = 0.5  # Start trailing after 0.5% profit\n    TRAILING_STOP_KEEP_PCT = 0.7        # Keep 70% of peak profit\n    \n    # === INDICATORS ===\n    RSI_PERIOD = 7\n    RSI_OVERSOLD = 35\n    RSI_OVERBOUGHT = 65\n    EMA_FAST = 8\n    EMA_SLOW = 21\n    EMA_TREND = 50\n    EMA_LONG_TREND = 200\n    VOLUME_SPIKE_MULTIPLIER = 2.0\n    WHALE_VOLUME_MULTIPLIER = 3.0\n    \n    # === MULTI-TIMEFRAME TREND (NEW!) ===\n    TIMEFRAMES = ['5m', '15m', '30m', '1h']\n    TIMEFRAME_WEIGHTS = {'5m': 1.0, '15m': 1.5, '30m': 2.0, '1h': 3.0}\n    STRONG_TREND_THRESHOLD = 30  # Score > 30 = strong uptrend, < -30 = strong downtrend\n    TREND_FILTER_ENABLED = True\n    \n    # === FUNDING RATES ===\n    FUNDING_THRESHOLD = 0.0001\n    FUNDING_CONFIDENCE_BOOST = 8\n    \n    # === TIME FILTERS ===\n    AVOID_FUNDING_WINDOW_SECONDS = 180\n    MIN_SIGNAL_AGE_SECONDS = 60\n    \n    # === POLLING ===\n    CHECK_INTERVAL_SECONDS = 30\n    POSITION_CHECK_INTERVAL = 10\n\n\nclass TechnicalAnalysis:\n    \"\"\"Technical indicator calculations\"\"\"\n    \n    @staticmethod\n    def calculate_rsi(closes: List[float], period: int = 7) -> Optional[float]:\n        \"\"\"RSI calculation\"\"\"\n        if len(closes) < period + 1:\n            return None\n        \n        deltas = [closes[i] - closes[i-1] for i in range(1, len(closes))]\n        gains = [max(d, 0) for d in deltas[-period:]]\n        losses = [max(-d, 0) for d in deltas[-period:]]\n        \n        avg_gain = sum(gains) / period\n        avg_loss = sum(losses) / period\n        \n        if avg_loss == 0:\n            return 100.0\n        \n        rs = avg_gain / avg_loss\n        return 100 - (100 / (1 + rs))\n    \n    @staticmethod\n    def calculate_ema(prices: List[float], period: int) -> Optional[float]:\n        \"\"\"EMA calculation\"\"\"\n        if len(prices) < period:\n            return None\n        \n        multiplier = 2 / (period + 1)\n        ema = sum(prices[:period]) / period\n        \n        for price in prices[period:]:\n            ema = (price - ema) * multiplier + ema\n        \n        return ema\n    \n    @staticmethod\n    def calculate_atr(candles: List[Dict], period: int = 14) -> Optional[float]:\n        \"\"\"Average True Range for volatility\"\"\"\n        if len(candles) < period + 1:\n            return None\n        \n        true_ranges = []\n        for i in range(1, len(candles)):\n            high = float(candles[i]['h'])\n            low = float(candles[i]['l'])\n            prev_close = float(candles[i-1]['c'])\n            \n            tr = max(high - low, abs(high - prev_close), abs(low - prev_close))\n            true_ranges.append(tr)\n        \n        return statistics.mean(true_ranges[-period:])\n    \n    @staticmethod\n    def detect_volume_spike(candles: List[Dict], lookback: int = 20) -> Tuple[bool, float]:\n        \"\"\"Detect volume spike\"\"\"\n        if len(candles) < lookback + 1:\n            return False, 0.0\n        \n        volumes = [float(c['v']) for c in candles[-(lookback+1):-1]]\n        current_volume = float(candles[-1]['v'])\n        avg_volume = statistics.mean(volumes)\n        \n        if avg_volume == 0:\n            return False, 0.0\n        \n        ratio = current_volume / avg_volume\n        is_spike = ratio >= Config.VOLUME_SPIKE_MULTIPLIER\n        \n        return is_spike, ratio\n    \n    @staticmethod\n    def is_higher_high(candles: List[Dict], lookback: int = 10) -> bool:\n        \"\"\"Check if making higher highs\"\"\"\n        if len(candles) < lookback + 1:\n            return False\n        \n        recent_highs = [float(c['h']) for c in candles[-lookback:]]\n        current_high = recent_highs[-1]\n        prev_high = max(recent_highs[:-1])\n        \n        return current_high > prev_high\n    \n    @staticmethod\n    def is_lower_low(candles: List[Dict], lookback: int = 10) -> bool:\n        \"\"\"Check if making lower lows\"\"\"\n        if len(candles) < lookback + 1:\n            return False\n        \n        recent_lows = [float(c['l']) for c in candles[-lookback:]]\n        current_low = recent_lows[-1]\n        prev_low = min(recent_lows[:-1])\n        \n        return current_low < prev_low\n\n\nclass MultiTimeframeTrend:\n    \"\"\"\n    \ud83c\udfaf CRITICAL: Multi-timeframe trend analysis\n    \n    Analyzes trend across 5m, 15m, 30m, 1h timeframes.\n    Returns trend score from -100 (strong downtrend) to +100 (strong uptrend).\n    \"\"\"\n    \n    @staticmethod\n    def calculate_timeframe_score(candles: List[Dict]) -> float:\n        \"\"\"Calculate trend score for a single timeframe\"\"\"\n        if not candles or len(candles) < 50:\n            return 0.0\n        \n        closes = [float(c['c']) for c in candles]\n        current_price = closes[-1]\n        \n        # Calculate EMAs\n        ema_8 = TechnicalAnalysis.calculate_ema(closes, 8)\n        ema_21 = TechnicalAnalysis.calculate_ema(closes, 21)\n        ema_50 = TechnicalAnalysis.calculate_ema(closes, 50)\n        \n        if None in [ema_8, ema_21, ema_50]:\n            return 0.0\n        \n        score = 0.0\n        \n        # 1. EMA STACKING (most important - 30 points)\n        if ema_8 > ema_21 > ema_50:\n            score += 30  # Perfect bullish stack\n        elif ema_8 < ema_21 < ema_50:\n            score -= 30  # Perfect bearish stack\n        elif ema_8 > ema_21:\n            score += 15  # Partial bullish\n        elif ema_8 < ema_21:\n            score -= 15  # Partial bearish\n        \n        # 2. PRICE vs EMAs (20 points total)\n        if current_price > ema_8:\n            score += 10\n        else:\n            score -= 10\n        \n        if current_price > ema_21:\n            score += 10\n        else:\n            score -= 10\n        \n        # 3. PRICE MOMENTUM - Higher highs / Lower lows (20 points)\n        if TechnicalAnalysis.is_higher_high(candles):\n            score += 20\n        if TechnicalAnalysis.is_lower_low(candles):\n            score -= 20\n        \n        # 4. DISTANCE FROM EMA (extra conviction - 10 points)\n        distance_from_ema21 = (current_price - ema_21) / ema_21\n        if distance_from_ema21 > 0.02:  # >2% above\n            score += 10\n        elif distance_from_ema21 < -0.02:  # >2% below\n            score -= 10\n        \n        return score\n    \n    @staticmethod\n    def get_trend_score(candles_by_tf: Dict[str, List[Dict]]) -> Tuple[float, str, str]:\n        \"\"\"\n        Calculate weighted multi-timeframe trend score.\n        \n        Returns:\n        - score: -100 to +100\n        - allowed_direction: 'LONG_ONLY', 'SHORT_ONLY', or 'BOTH'\n        - regime: Market regime classification\n        \"\"\"\n        scores = {}\n        weights = Config.TIMEFRAME_WEIGHTS\n        \n        for tf in Config.TIMEFRAMES:\n            if tf not in candles_by_tf:\n                continue\n            \n            candles = candles_by_tf[tf]\n            tf_score = MultiTimeframeTrend.calculate_timeframe_score(candles)\n            \n            # Weight by timeframe importance (1h = most important)\n            weight = weights.get(tf, 1.0)\n            scores[tf] = tf_score * weight\n        \n        if not scores:\n            return 0.0, 'BOTH', 'RANGING'\n        \n        # Calculate weighted average\n        total_weight = sum(weights[tf] for tf in scores.keys())\n        total_score = sum(scores.values()) / total_weight\n        \n        # Determine allowed trading direction\n        if total_score > Config.STRONG_TREND_THRESHOLD:\n            allowed_direction = 'LONG_ONLY'  # \ud83d\udeab NO SHORTS!\n            regime = 'STRONG_TREND_UP' if total_score > 50 else 'WEAK_TREND_UP'\n        elif total_score < -Config.STRONG_TREND_THRESHOLD:\n            allowed_direction = 'SHORT_ONLY'  # \ud83d\udeab NO LONGS!\n            regime = 'STRONG_TREND_DOWN' if total_score < -50 else 'WEAK_TREND_DOWN'\n        else:\n            allowed_direction = 'BOTH'  # Ranging - can trade both\n            regime = 'RANGING'\n        \n        return total_score, allowed_direction, regime\n\n\nclass TrendFilter:\n    \"\"\"\n    \ud83d\udee1\ufe0f CRITICAL: Trend-based signal filtering\n    \n    BLOCKS trades that fight the trend!\n    \"\"\"\n    \n    @staticmethod\n    def filter_signal(\n        signal: ScalpingSignal,\n        trend_score: float,\n        allowed_direction: str,\n        regime: str\n    ) -> Tuple[bool, str]:\n        \"\"\"\n        Filter signals based on multi-timeframe trend.\n        \n        HARD RULES:\n        - If trend_score > 30: BLOCK ALL SHORTS\n        - If trend_score < -30: BLOCK ALL LONGS\n        \"\"\"\n        \n        # \ud83d\udeab CRITICAL: Block counter-trend trades in strong trends\n        if allowed_direction == 'LONG_ONLY' and signal.side == TradeSide.SHORT:\n            return False, f\"\u274c BLOCKED: Shorting in uptrend (score: {trend_score:.1f})\"\n        \n        if allowed_direction == 'SHORT_ONLY' and signal.side == TradeSide.LONG:\n            return False, f\"\u274c BLOCKED: Longing in downtrend (score: {trend_score:.1f})\"\n        \n        # \u2705 BOOST: Trend-following trades get confidence boost\n        if allowed_direction == 'LONG_ONLY' and signal.side == TradeSide.LONG:\n            signal.confidence *= 1.15  # 15% boost\n            signal.reasons.append(f\"\u2705 Trend-following LONG (score: {trend_score:.1f})\")\n            \n            # Enable trailing stop for strong trend trades\n            if regime in ['STRONG_TREND_UP', 'STRONG_TREND_DOWN']:\n                signal.use_trailing_stop = True\n                signal.reasons.append(\"\ud83d\udcc8 Trailing stop enabled (strong trend)\")\n        \n        elif allowed_direction == 'SHORT_ONLY' and signal.side == TradeSide.SHORT:\n            signal.confidence *= 1.15\n            signal.reasons.append(f\"\u2705 Trend-following SHORT (score: {trend_score:.1f})\")\n            \n            if regime in ['STRONG_TREND_UP', 'STRONG_TREND_DOWN']:\n                signal.use_trailing_stop = True\n                signal.reasons.append(\"\ud83d\udcc9 Trailing stop enabled (strong trend)\")\n        \n        # Store trend context in signal\n        signal.trend_score = trend_score\n        signal.regime = regime\n        \n        return True, \"OK\"\n\n\nclass AdaptiveExitManager:\n    \"\"\"\n    \ud83c\udfaf CRITICAL: Adaptive exit management\n    \n    - Strong trends: Use trailing stops to let winners run\n    - Weak trends: Take profit quickly\n    - Ranging: Standard stops\n    \"\"\"\n    \n    @staticmethod\n    def should_exit(\n        position: ScalpingSignal,\n        current_price: float,\n        trend_score: float\n    ) -> Tuple[bool, str]:\n        \"\"\"Determine if position should be exited\"\"\"\n        \n        # Calculate current P&L\n        if position.side == TradeSide.LONG:\n            pnl_pct = ((current_price - position.entry_price) / position.entry_price) * 100\n        else:\n            pnl_pct = ((position.entry_price - current_price) / position.entry_price) * 100\n        \n        # Update highest P&L for trailing stop\n        if pnl_pct > position.highest_pnl:\n            position.highest_pnl = pnl_pct\n        \n        # 1. CHECK STOP LOSS (always check first!)\n        if position.side == TradeSide.LONG:\n            if current_price <= position.stop_loss:\n                return True, \"STOP_LOSS\"\n        else:\n            if current_price >= position.stop_loss:\n                return True, \"STOP_LOSS\"\n        \n        # 2. TRAILING STOP (for strong trend trades)\n        if position.use_trailing_stop and pnl_pct > Config.TRAILING_STOP_ACTIVATION_PCT:\n            # Keep 70% of peak profit\n            trailing_threshold = position.highest_pnl * Config.TRAILING_STOP_KEEP_PCT\n            \n            if pnl_pct < trailing_threshold:\n                return True, f\"TRAILING_STOP (locked {trailing_threshold:.2f}%)\"\n        \n        # 3. TAKE PROFIT (skip if trailing stop enabled - let winners run!)\n        if not position.use_trailing_stop:\n            if position.side == TradeSide.LONG:\n                if current_price >= position.take_profit:\n                    return True, \"TAKE_PROFIT\"\n            else:\n                if current_price <= position.take_profit:\n                    return True, \"TAKE_PROFIT\"\n        \n        # 4. QUICK EXIT in weak trends (take half profit early)\n        if abs(trend_score) < 20:  # Weak/ranging market\n            target_pct = abs((position.take_profit - position.entry_price) / position.entry_price) * 100\n            if pnl_pct >= target_pct * 0.5:  # Hit half target\n                return True, \"QUICK_PROFIT (weak trend)\"\n        \n        return False, None\n\n\nclass RegimeAdaptation:\n    \"\"\"\n    \ud83c\udfaf Market regime detection and adaptation\n    \n    Adapts strategy parameters based on market regime.\n    \"\"\"\n    \n    REGIMES = {\n        'STRONG_TREND_UP': {\n            'allowed': 'LONG_ONLY',\n            'hold_multiplier': 2.0,\n            'position_multiplier': 1.2,  # Larger positions\n            'min_confidence': 60  # Lower bar (trend is the edge)\n        },\n        'WEAK_TREND_UP': {\n            'allowed': 'LONG_ONLY',\n            'hold_multiplier': 1.5,\n            'position_multiplier': 1.0,\n            'min_confidence': 65\n        },\n        'RANGING': {\n            'allowed': 'BOTH',\n            'hold_multiplier': 0.5,  # Quick scalps in ranging - exit fast!\n            'position_multiplier': 1.0,  # Normal position size for scalps\n            'min_confidence': 55  # Lower bar for quick scalps\n        },\n        'WEAK_TREND_DOWN': {\n            'allowed': 'SHORT_ONLY',\n            'hold_multiplier': 1.5,\n            'position_multiplier': 1.0,\n            'min_confidence': 65\n        },\n        'STRONG_TREND_DOWN': {\n            'allowed': 'SHORT_ONLY',\n            'hold_multiplier': 2.0,\n            'position_multiplier': 1.2,\n            'min_confidence': 60\n        }\n    }\n    \n    @staticmethod\n    def get_regime_params(regime: str) -> Dict:\n        \"\"\"Get trading parameters for current regime\"\"\"\n        return RegimeAdaptation.REGIMES.get(regime, RegimeAdaptation.REGIMES['RANGING'])\n\n\nclass FundingAwareTrading:\n    \"\"\"Integrate funding rates\"\"\"\n    \n    @staticmethod\n    def adjust_for_funding(\n        signal: ScalpingSignal,\n        funding_rate: float,\n        hold_time_hours: float = 2.0\n    ) -> ScalpingSignal:\n        \"\"\"Adjust signal based on funding rate\"\"\"\n        \n        if abs(funding_rate) < Config.FUNDING_THRESHOLD:\n            return signal\n        \n        funding_periods = hold_time_hours / 8.0\n        expected_funding = funding_rate * funding_periods * 100\n        \n        if funding_rate < -Config.FUNDING_THRESHOLD:\n            if signal.side == TradeSide.LONG:\n                signal.confidence += Config.FUNDING_CONFIDENCE_BOOST\n                signal.reasons.append(f\"\ud83d\udcc8 Funding favors longs ({funding_rate:.4f})\")\n            else:\n                signal.confidence -= Config.FUNDING_CONFIDENCE_BOOST // 2\n        elif funding_rate > Config.FUNDING_THRESHOLD:\n            if signal.side == TradeSide.SHORT:\n                signal.confidence += Config.FUNDING_CONFIDENCE_BOOST\n                signal.reasons.append(f\"\ud83d\udcc9 Funding favors shorts (+{funding_rate:.4f})\")\n            else:\n                signal.confidence -= Config.FUNDING_CONFIDENCE_BOOST // 2\n        \n        return signal\n\n\nclass DynamicStopCalculator:\n    \"\"\"ATR-based dynamic stops\"\"\"\n    \n    @staticmethod\n    def calculate_stop_loss(\n        entry_price: float,\n        side: TradeSide,\n        atr: float,\n        strategy: SignalType\n    ) -> float:\n        \"\"\"Calculate stop loss based on ATR\"\"\"\n        \n        multipliers = {\n            SignalType.MOMENTUM: Config.MOMENTUM_STOP_ATR,\n            SignalType.PULLBACK: Config.PULLBACK_STOP_ATR,\n            SignalType.BREAKOUT: Config.BREAKOUT_STOP_ATR,\n            SignalType.VOLUME_SPIKE: Config.VOLUME_STOP_ATR,\n            SignalType.WHALE_MODE: Config.WHALE_STOP_ATR,\n        }\n        \n        multiplier = multipliers.get(strategy, 1.5)\n        stop_distance = atr * multiplier\n        \n        min_stop = entry_price * Config.MIN_STOP_PCT\n        max_stop = entry_price * Config.MAX_STOP_PCT\n        stop_distance = max(min_stop, min(stop_distance, max_stop))\n        \n        if side == TradeSide.LONG:\n            return entry_price - stop_distance\n        else:\n            return entry_price + stop_distance\n    \n    @staticmethod\n    def calculate_take_profit(\n        entry_price: float,\n        side: TradeSide,\n        atr: float,\n        strategy: SignalType\n    ) -> float:\n        \"\"\"Calculate take profit based on ATR\"\"\"\n        \n        multipliers = {\n            SignalType.MOMENTUM: Config.MOMENTUM_TARGET_ATR,\n            SignalType.PULLBACK: Config.PULLBACK_TARGET_ATR,\n            SignalType.BREAKOUT: Config.BREAKOUT_TARGET_ATR,\n            SignalType.VOLUME_SPIKE: Config.VOLUME_TARGET_ATR,\n            SignalType.WHALE_MODE: Config.WHALE_TARGET_ATR,\n        }\n        \n        multiplier = multipliers.get(strategy, 2.0)\n        target_distance = atr * multiplier\n        \n        # \ud83c\udfaf SCALP MODE: Cap target at MAX_TARGET_PCT (3%)\n        max_target = entry_price * Config.MAX_TARGET_PCT\n        min_target = entry_price * Config.MIN_TARGET_PCT\n        target_distance = max(min_target, min(target_distance, max_target))\n        \n        if side == TradeSide.LONG:\n            return entry_price + target_distance\n        else:\n            return entry_price - target_distance\n\n\nclass MomentumStrategy:\n    \"\"\"Momentum trading with trend confirmation\"\"\"\n    \n    @staticmethod\n    def generate_signal(\n        candles: List[Dict],\n        current_price: float,\n        allowed_direction: str\n    ) -> Optional[ScalpingSignal]:\n        \"\"\"Generate momentum signal (trend-following only!)\"\"\"\n        \n        if not candles or len(candles) < 50:\n            return None\n        \n        # Skip if ranging (momentum works best in trends)\n        if allowed_direction == 'BOTH':\n            return None\n        \n        closes = [float(c['c']) for c in candles]\n        \n        rsi = TechnicalAnalysis.calculate_rsi(closes, Config.RSI_PERIOD)\n        ema_fast = TechnicalAnalysis.calculate_ema(closes, Config.EMA_FAST)\n        ema_slow = TechnicalAnalysis.calculate_ema(closes, Config.EMA_SLOW)\n        atr = TechnicalAnalysis.calculate_atr(candles)\n        \n        if None in [rsi, ema_fast, ema_slow, atr]:\n            return None\n        \n        confidence = 0\n        reasons = []\n        side = None\n        \n        # LONG MOMENTUM\n        if allowed_direction == 'LONG_ONLY':\n            if ema_fast > ema_slow:\n                confidence += 30\n                reasons.append(f\"EMA golden cross\")\n                \n                if current_price > ema_fast:\n                    confidence += 15\n                    reasons.append(\"Price above fast EMA\")\n                \n                if 40 < rsi < 70:\n                    confidence += 20\n                    reasons.append(f\"RSI sweet spot ({rsi:.1f})\")\n                \n                if closes[-1] > closes[-2] > closes[-3]:\n                    confidence += 10\n                    reasons.append(\"3-candle bullish\")\n                \n                if confidence >= Config.MIN_CONFIDENCE_MOMENTUM:\n                    side = TradeSide.LONG\n        \n        # SHORT MOMENTUM\n        elif allowed_direction == 'SHORT_ONLY':\n            if ema_fast < ema_slow:\n                confidence += 30\n                reasons.append(f\"EMA death cross\")\n                \n                if current_price < ema_fast:\n                    confidence += 15\n                    reasons.append(\"Price below fast EMA\")\n                \n                if 30 < rsi < 60:\n                    confidence += 20\n                    reasons.append(f\"RSI sweet spot ({rsi:.1f})\")\n                \n                if closes[-1] < closes[-2] < closes[-3]:\n                    confidence += 10\n                    reasons.append(\"3-candle bearish\")\n                \n                if confidence >= Config.MIN_CONFIDENCE_MOMENTUM:\n                    side = TradeSide.SHORT\n        \n        if not side:\n            return None\n        \n        stop_loss = DynamicStopCalculator.calculate_stop_loss(\n            current_price, side, atr, SignalType.MOMENTUM\n        )\n        take_profit = DynamicStopCalculator.calculate_take_profit(\n            current_price, side, atr, SignalType.MOMENTUM\n        )\n        \n        return ScalpingSignal(\n            signal_type=SignalType.MOMENTUM,\n            side=side,\n            confidence=min(confidence, 100),\n            entry_price=current_price,\n            stop_loss=stop_loss,\n            take_profit=take_profit,\n            leverage=Config.DEFAULT_LEVERAGE,\n            reasons=reasons,\n            atr=atr\n        )\n\n\nclass PullbackStrategy:\n    \"\"\"Trade pullbacks in trends\"\"\"\n    \n    @staticmethod\n    def generate_signal(\n        candles: List[Dict],\n        current_price: float,\n        allowed_direction: str,\n        trend_score: float\n    ) -> Optional[ScalpingSignal]:\n        \"\"\"Find pullbacks in strong trends\"\"\"\n        \n        # Only in trending markets (not ranging)\n        if allowed_direction == 'BOTH':\n            return None\n        \n        # Need strong trend (score > 50 or < -50)\n        if abs(trend_score) < 50:\n            return None\n        \n        if not candles or len(candles) < 50:\n            return None\n        \n        closes = [float(c['c']) for c in candles]\n        rsi = TechnicalAnalysis.calculate_rsi(closes, Config.RSI_PERIOD)\n        ema_20 = TechnicalAnalysis.calculate_ema(closes, 20)\n        ema_50 = TechnicalAnalysis.calculate_ema(closes, Config.EMA_TREND)\n        atr = TechnicalAnalysis.calculate_atr(candles)\n        \n        if None in [rsi, ema_20, ema_50, atr]:\n            return None\n        \n        confidence = 0\n        reasons = []\n        side = None\n        \n        # LONG PULLBACK in UPTREND\n        if allowed_direction == 'LONG_ONLY':\n            distance_to_ema20 = abs(current_price - ema_20) / ema_20\n            \n            if distance_to_ema20 < 0.01:\n                confidence += 35\n                reasons.append(f\"Pullback to EMA20\")\n                \n                if rsi < 50:\n                    confidence += 20\n                    reasons.append(f\"RSI dip ({rsi:.1f})\")\n                \n                if current_price > ema_50:\n                    confidence += 20\n                    reasons.append(\"Trend intact\")\n                \n                if closes[-2] < closes[-3] and closes[-1] > closes[-2]:\n                    confidence += 15\n                    reasons.append(\"Bounce forming\")\n                \n                if confidence >= Config.MIN_CONFIDENCE_PULLBACK:\n                    side = TradeSide.LONG\n        \n        # SHORT PULLBACK in DOWNTREND\n        elif allowed_direction == 'SHORT_ONLY':\n            distance_to_ema20 = abs(current_price - ema_20) / ema_20\n            \n            if distance_to_ema20 < 0.01:\n                confidence += 35\n                reasons.append(f\"Rally to EMA20\")\n                \n                if rsi > 50:\n                    confidence += 20\n                    reasons.append(f\"RSI rally ({rsi:.1f})\")\n                \n                if current_price < ema_50:\n                    confidence += 20\n                    reasons.append(\"Downtrend intact\")\n                \n                if closes[-2] > closes[-3] and closes[-1] < closes[-2]:\n                    confidence += 15\n                    reasons.append(\"Rejection forming\")\n                \n                if confidence >= Config.MIN_CONFIDENCE_PULLBACK:\n                    side = TradeSide.SHORT\n        \n        if not side:\n            return None\n        \n        stop_loss = DynamicStopCalculator.calculate_stop_loss(\n            current_price, side, atr, SignalType.PULLBACK\n        )\n        take_profit = DynamicStopCalculator.calculate_take_profit(\n            current_price, side, atr, SignalType.PULLBACK\n        )\n        \n        return ScalpingSignal(\n            signal_type=SignalType.PULLBACK,\n            side=side,\n            confidence=min(confidence, 100),\n            entry_price=current_price,\n            stop_loss=stop_loss,\n            take_profit=take_profit,\n            leverage=Config.DEFAULT_LEVERAGE,\n            reasons=reasons,\n            atr=atr\n        )\n\n\nclass BreakoutStrategy:\n    \"\"\"Breakout trading\"\"\"\n    \n    @staticmethod\n    def generate_signal(\n        candles: List[Dict],\n        current_price: float\n    ) -> Optional[ScalpingSignal]:\n        \"\"\"Generate breakout signal\"\"\"\n        \n        if not candles or len(candles) < 50:\n            return None\n        \n        closes = [float(c['c']) for c in candles]\n        highs = [float(c['h']) for c in candles]\n        lows = [float(c['l']) for c in candles]\n        \n        atr = TechnicalAnalysis.calculate_atr(candles)\n        if not atr:\n            return None\n        \n        lookback = 20\n        recent_high = max(highs[-lookback:-1])\n        recent_low = min(lows[-lookback:-1])\n        \n        is_volume_spike, volume_ratio = TechnicalAnalysis.detect_volume_spike(candles)\n        \n        confidence = 0\n        reasons = []\n        side = None\n        \n        # BULLISH BREAKOUT\n        if current_price > recent_high:\n            breakout_pct = ((current_price - recent_high) / recent_high) * 100\n            confidence += 35\n            reasons.append(f\"Broke {lookback}-bar high\")\n            \n            if breakout_pct > 0.5:\n                confidence += 15\n                reasons.append(f\"Strong breakout ({breakout_pct:.2f}%)\")\n            \n            if is_volume_spike:\n                confidence += 20\n                reasons.append(f\"Volume ({volume_ratio:.1f}x)\")\n            \n            if confidence >= Config.MIN_CONFIDENCE_BREAKOUT:\n                side = TradeSide.LONG\n        \n        # BEARISH BREAKOUT\n        elif current_price < recent_low:\n            breakout_pct = ((recent_low - current_price) / recent_low) * 100\n            confidence += 35\n            reasons.append(f\"Broke {lookback}-bar low\")\n            \n            if breakout_pct > 0.5:\n                confidence += 15\n                reasons.append(f\"Strong breakdown ({breakout_pct:.2f}%)\")\n            \n            if is_volume_spike:\n                confidence += 20\n                reasons.append(f\"Volume ({volume_ratio:.1f}x)\")\n            \n            if confidence >= Config.MIN_CONFIDENCE_BREAKOUT:\n                side = TradeSide.SHORT\n        \n        if not side:\n            return None\n        \n        stop_loss = DynamicStopCalculator.calculate_stop_loss(\n            current_price, side, atr, SignalType.BREAKOUT\n        )\n        take_profit = DynamicStopCalculator.calculate_take_profit(\n            current_price, side, atr, SignalType.BREAKOUT\n        )\n        \n        return ScalpingSignal(\n            signal_type=SignalType.BREAKOUT,\n            side=side,\n            confidence=min(confidence, 100),\n            entry_price=current_price,\n            stop_loss=stop_loss,\n            take_profit=take_profit,\n            leverage=Config.DEFAULT_LEVERAGE,\n            reasons=reasons,\n            atr=atr\n        )\n\n\nclass VolumeSpikeStrategy:\n    \"\"\"Volume-based entries\"\"\"\n    \n    @staticmethod\n    def generate_signal(\n        candles: List[Dict],\n        current_price: float\n    ) -> Optional[ScalpingSignal]:\n        \"\"\"Volume spike detection\"\"\"\n        \n        if not candles or len(candles) < 30:\n            return None\n        \n        is_spike, volume_ratio = TechnicalAnalysis.detect_volume_spike(candles)\n        \n        if not is_spike:\n            return None\n        \n        is_whale_mode = volume_ratio >= Config.WHALE_VOLUME_MULTIPLIER\n        \n        closes = [float(c['c']) for c in candles]\n        current_candle = candles[-1]\n        atr = TechnicalAnalysis.calculate_atr(candles)\n        \n        candle_open = float(current_candle['o'])\n        candle_close = float(current_candle['c'])\n        candle_high = float(current_candle['h'])\n        candle_low = float(current_candle['l'])\n        \n        is_bullish_candle = candle_close > candle_open\n        candle_body = abs(candle_close - candle_open)\n        candle_range = candle_high - candle_low\n        \n        if candle_range == 0 or not atr:\n            return None\n        \n        body_ratio = candle_body / candle_range\n        \n        confidence = 0\n        reasons = []\n        side = None\n        \n        signal_type = SignalType.WHALE_MODE if is_whale_mode else SignalType.VOLUME_SPIKE\n        \n        if is_whale_mode:\n            reasons.append(f\"\ud83d\udc0b WHALE MODE ({volume_ratio:.1f}x)\")\n        else:\n            reasons.append(f\"Volume spike ({volume_ratio:.1f}x)\")\n        \n        if is_bullish_candle:\n            confidence += 35\n            \n            if body_ratio > 0.6:\n                confidence += 15\n                reasons.append(f\"Strong bullish body\")\n            \n            if is_whale_mode:\n                confidence += 20\n            \n            min_conf = Config.MIN_CONFIDENCE_WHALE if is_whale_mode else Config.MIN_CONFIDENCE_VOLUME\n            if confidence >= min_conf:\n                side = TradeSide.LONG\n        else:\n            confidence += 35\n            \n            if body_ratio > 0.6:\n                confidence += 15\n                reasons.append(f\"Strong bearish body\")\n            \n            if is_whale_mode:\n                confidence += 20\n            \n            min_conf = Config.MIN_CONFIDENCE_WHALE if is_whale_mode else Config.MIN_CONFIDENCE_VOLUME\n            if confidence >= min_conf:\n                side = TradeSide.SHORT\n        \n        if not side:\n            return None\n        \n        stop_loss = DynamicStopCalculator.calculate_stop_loss(\n            current_price, side, atr, signal_type\n        )\n        take_profit = DynamicStopCalculator.calculate_take_profit(\n            current_price, side, atr, signal_type\n        )\n        \n        return ScalpingSignal(\n            signal_type=signal_type,\n            side=side,\n            confidence=min(confidence, 100),\n            entry_price=current_price,\n            stop_loss=stop_loss,\n            take_profit=take_profit,\n            leverage=Config.DEFAULT_LEVERAGE,\n            reasons=reasons,\n            atr=atr\n        )\n\n\nclass KellyPositionSizer:\n    \"\"\"Kelly Criterion-based position sizing\"\"\"\n    \n    @staticmethod\n    def calculate_position_size(\n        balance: float,\n        win_rate: float,\n        avg_win: float,\n        avg_loss: float\n    ) -> float:\n        \"\"\"Calculate optimal position size\"\"\"\n        \n        if avg_loss == 0:\n            return max(balance * 0.03, Config.MIN_POSITION_USD)\n        \n        win_loss_ratio = avg_win / abs(avg_loss)\n        loss_prob = 1 - win_rate\n        \n        kelly = (win_loss_ratio * win_rate - loss_prob) / win_loss_ratio\n        fractional_kelly = kelly * 0.25\n        fractional_kelly = max(0.02, min(Config.MAX_POSITION_PCT, fractional_kelly))\n        \n        position_size = balance * fractional_kelly\n        return max(position_size, Config.MIN_POSITION_USD)\n\n\nclass MarketData:\n    \"\"\"Market data fetching\"\"\"\n    \n    def __init__(self, info: Info):\n        self.info = info\n    \n    def get_price(self, asset: str) -> Optional[float]:\n        \"\"\"Get current price\"\"\"\n        try:\n            mids = self.info.all_mids()\n            return float(mids.get(asset, 0))\n        except Exception as e:\n            print(f\"\u274c Price fetch error: {e}\")\n            return None\n    \n    def get_funding_rate(self, asset: str) -> float:\n        \"\"\"Get funding rate\"\"\"\n        try:\n            meta = self.info.meta()\n            contexts = self.info.meta_and_asset_ctxs()\n            \n            if contexts and len(contexts) > 1:\n                asset_ctxs = contexts[1]\n                for i, item in enumerate(meta.get(\"universe\", [])):\n                    if item.get(\"name\") == asset and i < len(asset_ctxs):\n                        return float(asset_ctxs[i].get(\"funding\", 0))\n            return 0.0\n        except:\n            return 0.0\n    \n    def get_candles(self, asset: str, timeframe: str, bars: int = 200) -> Optional[List[Dict]]:\n        \"\"\"Get candles\"\"\"\n        try:\n            now_ms = int(time.time() * 1000)\n            tf_minutes = {\"1m\": 1, \"5m\": 5, \"15m\": 15, \"30m\": 30, \"1h\": 60}\n            minutes = tf_minutes.get(timeframe, 5)\n            lookback_ms = bars * minutes * 60 * 1000\n            \n            return self.info.candles_snapshot(asset, timeframe, now_ms - lookback_ms, now_ms)\n        except Exception as e:\n            print(f\"\u274c Candle fetch error ({timeframe}): {e}\")\n            return None\n    \n    def get_multi_timeframe_candles(self, asset: str) -> Dict[str, List[Dict]]:\n        \"\"\"Get candles for all timeframes\"\"\"\n        candles_by_tf = {}\n        \n        for tf in Config.TIMEFRAMES:\n            candles = self.get_candles(asset, tf, bars=200)\n            if candles:\n                candles_by_tf[tf] = candles\n        \n        return candles_by_tf\n\n\nclass RiskManager:\n    \"\"\"Risk management\"\"\"\n    \n    def __init__(self, state: RiskState):\n        self.state = state\n    \n    def can_trade(self, balance: float) -> Tuple[bool, str]:\n        \"\"\"Check if trading is allowed\"\"\"\n        \n        today = datetime.now().strftime(\"%Y-%m-%d\")\n        if self.state.last_reset_date != today:\n            self.state.daily_pnl = 0.0\n            self.state.daily_trades = 0\n            self.state.last_reset_date = today\n        \n        if self.state.paused_until:\n            pause_time = datetime.fromisoformat(self.state.paused_until)\n            if datetime.now() < pause_time:\n                remaining = (pause_time - datetime.now()).seconds // 60\n                return False, f\"Paused for {remaining} more minutes\"\n            else:\n                self.state.paused_until = None\n                self.state.consecutive_losses = 0\n        \n        if self.state.daily_pnl <= -Config.DAILY_LOSS_LIMIT:\n            return False, f\"Daily loss limit (${abs(self.state.daily_pnl):.2f})\"\n        \n        if self.state.daily_trades >= Config.MAX_DAILY_TRADES:\n            return False, f\"Max daily trades ({Config.MAX_DAILY_TRADES})\"\n        \n        if self.state.consecutive_losses >= Config.MAX_CONSECUTIVE_LOSSES:\n            pause_until = datetime.now() + timedelta(minutes=Config.PAUSE_DURATION_MINUTES)\n            self.state.paused_until = pause_until.isoformat()\n            return False, f\"Max consecutive losses\"\n        \n        if len(self.state.open_positions) >= Config.MAX_POSITIONS:\n            return False, f\"Max positions ({Config.MAX_POSITIONS})\"\n        \n        if self.state.peak_balance > 0:\n            drawdown = ((self.state.peak_balance - balance) / self.state.peak_balance) * 100\n            if drawdown >= Config.MAX_DRAWDOWN_PCT:\n                return False, f\"Max drawdown ({drawdown:.1f}%)\"\n        \n        return True, \"OK\"\n    \n    def update_peak_balance(self, balance: float):\n        \"\"\"Track peak\"\"\"\n        if balance > self.state.peak_balance:\n            self.state.peak_balance = balance\n    \n    def record_trade_result(self, pnl: float, is_win: bool):\n        \"\"\"Record trade\"\"\"\n        self.state.daily_pnl += pnl\n        self.state.total_trades += 1\n        self.state.daily_trades += 1\n        \n        if is_win:\n            self.state.winning_trades += 1\n            self.state.consecutive_losses = 0\n        else:\n            self.state.losing_trades += 1\n            self.state.consecutive_losses += 1\n\n\nclass HyperliquidScalpingBotV2:\n    \"\"\"Multi-timeframe trend-following bot\"\"\"\n    \n    def __init__(self, config_file: str = \".hyperliquid_config.json\"):\n        print(\"=\" * 70)\n        print(\"\ud83d\ude80 HYPERLIQUID BOT V2.1 - MULTI-TIMEFRAME TREND FOLLOWING \ud83d\ude80\")\n        print(\"=\" * 70)\n        print(f\"\u23f0 Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        \n        with open(config_file, 'r') as f:\n            hl_config = json.load(f)\n        \n        self.wallet_address = hl_config[\"public_wallet\"]\n        self.api_key = hl_config[\"api_private_key\"]\n        \n        self.info = Info(skip_ws=True)\n        account = Account.from_key(self.api_key)\n        self.exchange = Exchange(account, account_address=self.wallet_address)\n        \n        self.market_data = MarketData(self.info)\n        self.risk_state = self._load_state()\n        self.risk_manager = RiskManager(self.risk_state)\n        \n        if LEARNING_ENABLED:\n            self.learning = LearningLayerManager(\n                history_file=\"hyperliquid_trade_history_v2.json\",\n                params_file=\"hyperliquid_learned_params_v2.json\"\n            )\n            print(\"\ud83e\udde0 Learning layer: ENABLED\")\n        else:\n            self.learning = None\n        \n        # Check for orphaned positions on startup\n        self._check_orphaned_positions()\n        \n        self.running = True\n        self.current_trade_id = None\n        \n        balance = self.get_account_balance()\n        if balance:\n            self.risk_manager.update_peak_balance(balance)\n            print(f\"\ud83d\udcb5 Balance: ${balance:.2f}\")\n        \n        print(\"\\n\" + \"=\" * 70)\n        print(\"\ud83c\udfaf V2.1 CRITICAL UPGRADES:\")\n        print(\"   \u2705 Multi-timeframe trend (5m/15m/30m/1h)\")\n        print(\"   \u2705 HARD BLOCKS - Never fight the trend!\")\n        print(\"   \u2705 Trailing stops - Let winners run!\")\n        print(\"   \u2705 Regime detection - Adapt to market!\")\n        print(\"   \u2705 Trend scoring (-100 to +100)\")\n        print(\"=\" * 70 + \"\\n\")\n    \n    def _load_state(self) -> RiskState:\n        \"\"\"Load state\"\"\"\n        state_file = \"scalping_state_v2.json\"\n        if os.path.exists(state_file):\n            try:\n                with open(state_file, 'r') as f:\n                    return RiskState(**json.load(f))\n            except:\n                pass\n        return RiskState()\n    \n    def _save_state(self):\n        \"\"\"Save state\"\"\"\n        try:\n            with open(\"scalping_state_v2.json\", 'w') as f:\n                json.dump({\n                    \"daily_pnl\": self.risk_state.daily_pnl,\n                    \"daily_trades\": self.risk_state.daily_trades,\n                    \"consecutive_losses\": self.risk_state.consecutive_losses,\n                    \"peak_balance\": self.risk_state.peak_balance,\n                    \"last_trade_time\": self.risk_state.last_trade_time,\n                    \"total_trades\": self.risk_state.total_trades,\n                    \"winning_trades\": self.risk_state.winning_trades,\n                    \"losing_trades\": self.risk_state.losing_trades,\n                    \"open_positions\": self.risk_state.open_positions,\n                    \"paused_until\": self.risk_state.paused_until,\n                    \"last_reset_date\": self.risk_state.last_reset_date\n                }, f, indent=2)\n        except Exception as e:\n            print(f\"\u26a0\ufe0f State save error: {e}\")\n    \n    def _check_orphaned_positions(self):\n        \"\"\"Check for and close any orphaned positions from old bots\"\"\"\n        try:\n            state = self.info.user_state(self.wallet_address)\n            positions = state.get('assetPositions', [])\n            \n            for p in positions:\n                pos = p.get('position', {})\n                size = float(pos.get('szi', 0))\n                if size != 0:\n                    entry = float(pos.get('entryPx', 0))\n                    asset = pos.get('coin', 'BTC')\n                    direction = \"LONG\" if size > 0 else \"SHORT\"\n                    \n                    print(f\"\\n\u26a0\ufe0f ORPHANED POSITION DETECTED!\")\n                    print(f\"   {direction} {abs(size)} {asset} @ ${entry:,.2f}\")\n                    print(f\"   Closing immediately...\")\n                    \n                    result = self.exchange.market_close(asset)\n                    print(f\"   \u2705 Closed: {result}\")\n                    \n        except Exception as e:\n            print(f\"\u26a0\ufe0f Orphan check error: {e}\")\n    \n    def get_account_balance(self) -> Optional[float]:\n        \"\"\"Get balance\"\"\"\n        try:\n            user_state = self.info.user_state(self.wallet_address)\n            margin_summary = user_state.get(\"marginSummary\", {})\n            return float(margin_summary.get(\"accountValue\", 0))\n        except Exception as e:\n            print(f\"\u274c Balance error: {e}\")\n            return None\n    \n    def generate_signals(self, asset: str = \"BTC\") -> List[ScalpingSignal]:\n        \"\"\"\n        \ud83c\udfaf CRITICAL: Generate signals with multi-timeframe trend filtering\n        \"\"\"\n        \n        current_price = self.market_data.get_price(asset)\n        if not current_price:\n            return []\n        \n        # 1. GET MULTI-TIMEFRAME CANDLES\n        print(f\"\\n\ud83d\udcca Fetching multi-timeframe data...\")\n        candles_by_tf = self.market_data.get_multi_timeframe_candles(asset)\n        \n        if not candles_by_tf:\n            print(\"\u274c No candle data available\")\n            return []\n        \n        print(f\"   \u2705 Loaded timeframes: {', '.join(candles_by_tf.keys())}\")\n        \n        # 2. CALCULATE MULTI-TIMEFRAME TREND SCORE\n        trend_score, allowed_direction, regime = MultiTimeframeTrend.get_trend_score(candles_by_tf)\n        \n        print(f\"\\n\ud83c\udfaf TREND ANALYSIS:\")\n        print(f\"   Score: {trend_score:.1f} (-100 to +100)\")\n        print(f\"   Direction: {allowed_direction}\")\n        print(f\"   Regime: {regime}\")\n        \n        # Get regime parameters\n        regime_params = RegimeAdaptation.get_regime_params(regime)\n        print(f\"   Min Confidence: {regime_params['min_confidence']}\")\n        print(f\"   Position Multiplier: {regime_params['position_multiplier']}\")\n        \n        # 3. GET FUNDING RATE\n        funding_rate = self.market_data.get_funding_rate(asset)\n        print(f\"   Funding: {funding_rate:.6f}\")\n        \n        # 4. GENERATE SIGNALS FROM STRATEGIES\n        candles_5m = candles_by_tf.get('5m')\n        if not candles_5m:\n            return []\n        \n        signals = []\n        \n        # Try each strategy\n        momentum_signal = MomentumStrategy.generate_signal(\n            candles_5m, current_price, allowed_direction\n        )\n        \n        pullback_signal = PullbackStrategy.generate_signal(\n            candles_5m, current_price, allowed_direction, trend_score\n        )\n        \n        breakout_signal = BreakoutStrategy.generate_signal(\n            candles_5m, current_price\n        )\n        \n        volume_signal = VolumeSpikeStrategy.generate_signal(\n            candles_5m, current_price\n        )\n        \n        # 5. FILTER SIGNALS THROUGH TREND FILTER\n        print(f\"\\n\ud83d\udd0d Signal Generation:\")\n        \n        for signal in [momentum_signal, pullback_signal, breakout_signal, volume_signal]:\n            if not signal:\n                continue\n            \n            # Apply trend filter (CRITICAL!)\n            should_take, reason = TrendFilter.filter_signal(\n                signal, trend_score, allowed_direction, regime\n            )\n            \n            if not should_take:\n                print(f\"   \u274c {signal.signal_type.value} {signal.side.value}: {reason}\")\n                continue\n            \n            # Apply funding adjustment\n            signal = FundingAwareTrading.adjust_for_funding(signal, funding_rate)\n            \n            # Check against regime minimum confidence\n            if signal.confidence < regime_params['min_confidence']:\n                print(f\"   \u274c {signal.signal_type.value} {signal.side.value}: Below regime min ({signal.confidence:.0f} < {regime_params['min_confidence']})\")\n                continue\n            \n            signals.append(signal)\n            print(f\"   \u2705 {signal.signal_type.value} {signal.side.value}: {signal.confidence:.0f}% confidence\")\n        \n        return signals\n    \n    def select_best_signal(self, signals: List[ScalpingSignal]) -> Optional[ScalpingSignal]:\n        \"\"\"Select highest confidence signal\"\"\"\n        if not signals:\n            return None\n        \n        signals.sort(key=lambda s: s.confidence, reverse=True)\n        return signals[0]\n    \n    def calculate_position_size(self, balance: float, signal: ScalpingSignal) -> float:\n        \"\"\"Calculate position size (Kelly + regime adaptation)\"\"\"\n        \n        if self.risk_state.total_trades >= 10:\n            win_rate = self.risk_state.winning_trades / self.risk_state.total_trades\n            avg_win = 5.0\n            avg_loss = -4.0\n            \n            size = KellyPositionSizer.calculate_position_size(\n                balance, win_rate, avg_win, avg_loss\n            )\n        else:\n            size = balance * 0.03\n        \n        # Adjust by regime\n        if signal.regime:\n            regime_params = RegimeAdaptation.get_regime_params(signal.regime)\n            size *= regime_params['position_multiplier']\n        \n        return max(size, Config.MIN_POSITION_USD)\n    \n    def execute_trade(self, signal: ScalpingSignal) -> bool:\n        \"\"\"Execute trade\"\"\"\n        \n        balance = self.get_account_balance()\n        if not balance:\n            return False\n        \n        position_size = self.calculate_position_size(balance, signal)\n        size_in_coins = position_size / signal.entry_price\n        size_in_coins = round(size_in_coins, 5)\n        \n        min_size = 0.0002\n        if size_in_coins < min_size:\n            size_in_coins = min_size\n            position_size = size_in_coins * signal.entry_price\n        \n        print(\"\\n\" + \"=\" * 70)\n        print(f\"\ud83c\udfaf EXECUTING {signal.side.value} TRADE\")\n        print(\"=\" * 70)\n        print(f\"\ud83d\udcc8 Strategy: {signal.signal_type.value}\")\n        print(f\"\ud83d\udcb0 Price: ${signal.entry_price:,.2f}\")\n        print(f\"\ud83d\udcca Size: ${position_size:.2f} ({size_in_coins:.5f} BTC)\")\n        print(f\"\u26a1 Leverage: {signal.leverage}x\")\n        print(f\"\ud83c\udfaf Confidence: {signal.confidence:.0f}%\")\n        print(f\"\ud83d\udcca Trend Score: {signal.trend_score:.1f}\")\n        print(f\"\ud83c\udf0a Regime: {signal.regime}\")\n        print(f\"\ud83d\uded1 Stop: ${signal.stop_loss:,.2f}\")\n        print(f\"\u2705 Target: ${signal.take_profit:,.2f}\")\n        \n        if signal.use_trailing_stop:\n            print(f\"\ud83d\udcc8 Trailing Stop: ENABLED (keep {Config.TRAILING_STOP_KEEP_PCT*100:.0f}% of peak)\")\n        \n        print(f\"\ud83d\udcdd Reasons:\")\n        for reason in signal.reasons:\n            print(f\"   \u2022 {reason}\")\n        \n        try:\n            is_buy = signal.side == TradeSide.LONG\n            \n            order_result = self.exchange.market_open(\n                \"BTC\",\n                is_buy,\n                size_in_coins,\n                px=None,\n                slippage=0.005\n            )\n            \n            print(f\"\\n\u2705 ORDER EXECUTED!\")\n            print(f\"   Result: {order_result}\")\n            \n            if self.learning:\n                self.current_trade_id = self.learning.record_trade_entry(\n                    asset=\"BTC\",\n                    direction=signal.side.value,\n                    strategy=signal.signal_type.value,\n                    entry_price=signal.entry_price,\n                    size_usd=position_size,\n                    size_coins=size_in_coins,\n                    leverage=signal.leverage,\n                    stop_loss=signal.stop_loss,\n                    take_profit=signal.take_profit,\n                    confidence=signal.confidence,\n                    reasons=signal.reasons,\n                    funding_rate=self.market_data.get_funding_rate(\"BTC\")\n                )\n            \n            self._save_state()\n            return True\n            \n        except Exception as e:\n            print(f\"\\n\u274c TRADE FAILED: {e}\")\n            traceback.print_exc()\n            return False\n    \n    def run(self):\n        \"\"\"Main loop\"\"\"\n        print(\"\\n\ud83d\ude80 Starting multi-timeframe trend-following bot...\")\n        \n        while self.running:\n            try:\n                balance = self.get_account_balance()\n                if not balance:\n                    time.sleep(Config.CHECK_INTERVAL_SECONDS)\n                    continue\n                \n                can_trade, reason = self.risk_manager.can_trade(balance)\n                if not can_trade:\n                    print(f\"\u23f8\ufe0f Cannot trade: {reason}\")\n                    time.sleep(Config.CHECK_INTERVAL_SECONDS)\n                    continue\n                \n                signals = self.generate_signals(\"BTC\")\n                \n                if signals:\n                    best_signal = self.select_best_signal(signals)\n                    if best_signal:\n                        self.execute_trade(best_signal)\n                \n                win_rate = (self.risk_state.winning_trades / self.risk_state.total_trades * 100) if self.risk_state.total_trades > 0 else 0\n                print(f\"\\n\ud83d\udcca Stats: {self.risk_state.total_trades} trades | {win_rate:.1f}% win rate | ${self.risk_state.daily_pnl:.2f} daily P&L\")\n                \n                time.sleep(Config.CHECK_INTERVAL_SECONDS)\n                \n            except KeyboardInterrupt:\n                print(\"\\n\\n\u23f9\ufe0f Shutting down...\")\n                self.running = False\n            except Exception as e:\n                print(f\"\u274c Error: {e}\")\n                traceback.print_exc()\n                time.sleep(Config.CHECK_INTERVAL_SECONDS)\n\n\nif __name__ == \"__main__\":\n    bot = HyperliquidScalpingBotV2()\n    bot.run()\n"
}