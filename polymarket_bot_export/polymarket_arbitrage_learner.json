{
  "filename": "polymarket_arbitrage_learner.py",
  "description": "Main bot - Chainlink lag arbitrage strategy with adaptive learning",
  "bugs_found": [
    "Line 46: PAPER_TRADING = False but no price targeting",
    "Line 236: pnl = 4.50 hardcoded - wrong at 0.99 odds"
  ],
  "code": "#!/usr/bin/env python3\n\"\"\"\nPolymarket Arbitrage Learner Bot\nCombines Chainlink lag arbitrage strategy with adaptive learning.\n\nTHE EDGE:\n- Polymarket 15-min BTC/ETH markets settle based on Chainlink oracle prices\n- Chainlink oracle LAGS behind Binance spot prices by seconds/minutes\n- When Binance shows a significant move (0.3%+) in first 5 minutes of window\n- Execute trade on Polymarket BEFORE the odds fully adjust\n- Market settles based on Chainlink â†’ we profit from the lag\n\nThis is NOT momentum trading (gambling).\nThis IS information arbitrage (exploiting the oracle lag).\n\"\"\"\n\nimport asyncio\nimport websockets\nimport json\nimport time\nimport sys\nsys.path.insert(0, '/Users/erik/.openclaw/workspace')\n\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Optional, List, Tuple\nfrom dataclasses import dataclass, asdict\nfrom collections import deque\n\n# Import our components\nfrom polymarket_clob_executor import PolymarketExecutor\nfrom polymarket_learning import LearningEngine\n\n# ============================================================================\n# CONFIGURATION\n# ============================================================================\n\n# Wallet\nPRIVATE_KEY = \"0x4badb53d27e3a1142c4bb509e4d00a64645401359a69afc928246666a2edac36\"\nWALLET_ADDRESS = \"0x114B7A51A4cF04897434408bd9003626705a2208\"\n\n# Mode\nPAPER_TRADING = False  # ðŸ”¥ LIVE TRADING - LET'S MAKE MONEY\nPOSITION_SIZE = 3.0    # $3 per trade (low funds)\n\n# ARBITRAGE STRATEGY PARAMETERS - HYPERACTIVE MODE\n# The edge is exploiting the LAG - not momentum\nMIN_PRICE_MOVE = 0.001       # 0.1% minimum move (hyperactive)\nMAX_TRADE_WINDOW = 600       # Trade in first 10 minutes (extended arbitrage window)\nMIN_BASE_CONFIDENCE = 0.35   # Lower threshold = more trades\n\n# Risk Management\nMAX_CONSECUTIVE_LOSSES = 4   # Pause after 4 losses in a row\nMAX_DAILY_LOSS = 20.0        # Stop trading if lose $20 in a day\nTRADE_COOLDOWN = 45          # 45 sec between trades (faster)\n\n# ============================================================================\n# DATA STRUCTURES\n# ============================================================================\n\n@dataclass\nclass ArbitrageWindow:\n    \"\"\"Represents a 15-minute market window for arbitrage\"\"\"\n    asset: str  # BTC or ETH\n    start_time: datetime\n    end_time: datetime\n    start_price: float\n    current_price: Optional[float] = None\n    market_slug: Optional[str] = None\n    token_yes_id: Optional[str] = None\n    token_no_id: Optional[str] = None\n    traded: bool = False\n    trade_direction: Optional[str] = None\n    last_trade_time: Optional[datetime] = None\n    \n    @property\n    def seconds_elapsed(self) -> int:\n        return int((datetime.now() - self.start_time).total_seconds())\n    \n    @property\n    def time_remaining(self) -> int:\n        return max(0, 900 - self.seconds_elapsed)  # 900 = 15 minutes\n    \n    @property\n    def in_arbitrage_window(self) -> bool:\n        \"\"\"True if we're in the first 5 minutes (where the lag is exploitable)\"\"\"\n        return self.seconds_elapsed < MAX_TRADE_WINDOW\n    \n    @property\n    def can_trade(self) -> bool:\n        \"\"\"Can we trade right now?\"\"\"\n        if not self.in_arbitrage_window:\n            return False  # Past the arbitrage window\n        if self.traded and self.trade_direction:\n            # Already traded this direction - check cooldown for reversal\n            if self.last_trade_time:\n                seconds_since_trade = (datetime.now() - self.last_trade_time).total_seconds()\n                return seconds_since_trade >= TRADE_COOLDOWN\n        return True\n    \n    @property\n    def price_change_pct(self) -> float:\n        \"\"\"Current price change from window start\"\"\"\n        if not self.start_price or not self.current_price:\n            return 0.0\n        return (self.current_price - self.start_price) / self.start_price\n\n@dataclass\nclass ArbitrageSignal:\n    \"\"\"An arbitrage opportunity signal\"\"\"\n    asset: str\n    direction: str  # UP or DOWN\n    base_confidence: float  # Raw confidence from arbitrage signal\n    adjusted_confidence: float  # After learning adjustments\n    price_change_pct: float\n    seconds_in_window: int\n    window_start_price: float\n    current_price: float\n    reason: str\n\n@dataclass\nclass DailyStats:\n    \"\"\"Track daily performance\"\"\"\n    date: str\n    total_trades: int = 0\n    wins: int = 0\n    losses: int = 0\n    pending: int = 0\n    total_pnl: float = 0.0\n    consecutive_losses: int = 0\n\n# ============================================================================\n# CHAINLINK LAG ARBITRAGE BOT WITH LEARNING\n# ============================================================================\n\nclass ArbitrageLearnerBot:\n    \"\"\"\n    The key insight:\n    - Binance moves first (real-time market)\n    - Chainlink oracle updates with a lag (seconds to minutes)\n    - Polymarket 15-min markets settle based on Chainlink\n    - If we see Binance move 0.5%, Polymarket odds haven't caught up yet\n    - We bet on the direction BEFORE the market prices it in\n    \n    This is TRUE arbitrage - not speculation on where price will go.\n    We already KNOW where price went (on Binance). We're betting\n    that Polymarket will settle in that direction because the oracle\n    will eventually update.\n    \"\"\"\n    \n    def __init__(self):\n        # Price tracking\n        self.prices = {'BTC': deque(maxlen=1000), 'ETH': deque(maxlen=1000)}\n        self.current_windows: Dict[str, ArbitrageWindow] = {}\n        self.completed_windows: List[ArbitrageWindow] = []\n        \n        # Initialize executor\n        self.executor = PolymarketExecutor(\n            private_key=PRIVATE_KEY,\n            wallet_address=WALLET_ADDRESS,\n            paper_mode=PAPER_TRADING\n        )\n        \n        # Initialize learning engine\n        self.learning = LearningEngine()\n        \n        # State tracking\n        self.pending_trades: Dict[str, dict] = {}  # market_slug -> trade info\n        self.daily_stats = self._init_daily_stats()\n        self.running = False\n        self.paused = False\n        \n        # Binance WebSocket URLs\n        self.ws_urls = {\n            'BTC': 'wss://stream.binance.com:9443/ws/btcusdt@trade',\n            'ETH': 'wss://stream.binance.com:9443/ws/ethusdt@trade'\n        }\n    \n    def _init_daily_stats(self) -> DailyStats:\n        \"\"\"Initialize daily stats\"\"\"\n        today = datetime.now().strftime(\"%Y-%m-%d\")\n        return DailyStats(date=today)\n    \n    def log(self, msg: str, level: str = \"INFO\"):\n        \"\"\"Enhanced logging\"\"\"\n        import sys\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n        emoji = {\n            \"INFO\": \"ðŸ“Š\",\n            \"SIGNAL\": \"ðŸŽ¯\",\n            \"EXECUTE\": \"âš¡\",\n            \"ARBITRAGE\": \"ðŸ’Ž\",\n            \"WIN\": \"âœ…\",\n            \"LOSS\": \"âŒ\",\n            \"PAUSE\": \"ðŸ›‘\",\n            \"ERROR\": \"ðŸ”¥\",\n            \"LEARN\": \"ðŸ§ \",\n            \"ADAPT\": \"ðŸ”§\",\n            \"WINDOW\": \"â°\"\n        }.get(level, \"â„¹ï¸\")\n        print(f\"[{timestamp}] {emoji} {msg}\", flush=True)\n    \n    def _check_safety_limits(self) -> bool:\n        \"\"\"Check if we should continue trading\"\"\"\n        # Daily loss limit\n        if self.daily_stats.total_pnl <= -MAX_DAILY_LOSS:\n            if not self.paused:\n                self.paused = True\n                self.log(f\"Daily loss limit hit: ${abs(self.daily_stats.total_pnl):.2f}\", \"PAUSE\")\n            return False\n        \n        # Consecutive losses\n        if self.daily_stats.consecutive_losses >= MAX_CONSECUTIVE_LOSSES:\n            if not self.paused:\n                self.paused = True\n                self.log(f\"{MAX_CONSECUTIVE_LOSSES} consecutive losses - pausing\", \"PAUSE\")\n            return False\n        \n        return True\n    \n    def _reset_pause_if_needed(self):\n        \"\"\"Reset pause after a win\"\"\"\n        if self.paused and self.daily_stats.consecutive_losses < MAX_CONSECUTIVE_LOSSES:\n            self.paused = False\n            self.log(\"Resuming trading after win\", \"INFO\")\n    \n    # =========================================================================\n    # PRICE & WINDOW MANAGEMENT\n    # =========================================================================\n    \n    def _get_window_key(self, asset: str, window_start: datetime) -> str:\n        \"\"\"Generate unique key for a window\"\"\"\n        return f\"{asset}_{int(window_start.timestamp())}\"\n    \n    def _create_new_window(self, asset: str, price: float) -> ArbitrageWindow:\n        \"\"\"Create a new 15-minute arbitrage window\"\"\"\n        now = datetime.now()\n        minute = now.minute\n        \n        # Find current 15-min window boundaries\n        window_start_minute = (minute // 15) * 15\n        window_start = now.replace(minute=window_start_minute, second=0, microsecond=0)\n        window_end = window_start + timedelta(minutes=15)\n        \n        # Market slug format\n        timestamp = int(window_start.timestamp())\n        market_slug = f\"{asset.lower()}-updown-15m-{timestamp}\"\n        \n        # Fetch token IDs\n        yes_token, no_token = self.executor.get_market_tokens(market_slug)\n        \n        window = ArbitrageWindow(\n            asset=asset,\n            start_time=window_start,\n            end_time=window_end,\n            start_price=price,\n            current_price=price,\n            market_slug=market_slug,\n            token_yes_id=yes_token,\n            token_no_id=no_token\n        )\n        \n        return window\n    \n    def _resolve_window(self, window: ArbitrageWindow, end_price: float):\n        \"\"\"Resolve all trades when a window ends\"\"\"\n        if not window.market_slug or window.market_slug not in self.pending_trades:\n            return\n        \n        pending = self.pending_trades.pop(window.market_slug)\n        \n        # Resolve in learning engine\n        self.learning.resolve_by_market_slug(\n            market_slug=window.market_slug,\n            window_end_price=end_price,\n            window_start_price=window.start_price\n        )\n        \n        # Determine actual outcome\n        actual_direction = \"UP\" if end_price > window.start_price else \"DOWN\"\n        is_win = pending['direction'] == actual_direction\n        \n        # Update stats\n        if is_win:\n            pnl = 4.50  # Conservative win estimate\n            self.daily_stats.wins += 1\n            self.daily_stats.consecutive_losses = 0\n            self._reset_pause_if_needed()\n            self.log(\n                f\"WIN: {window.asset} {pending['direction']} | \"\n                f\"Start: ${window.start_price:,.2f} â†’ End: ${end_price:,.2f} | \"\n                f\"+${pnl:.2f}\",\n                \"WIN\"\n            )\n        else:\n            pnl = -POSITION_SIZE\n            self.daily_stats.losses += 1\n            self.daily_stats.consecutive_losses += 1\n            self.log(\n                f\"LOSS: {window.asset} {pending['direction']} | \"\n                f\"Start: ${window.start_price:,.2f} â†’ End: ${end_price:,.2f} | \"\n                f\"-${POSITION_SIZE:.2f}\",\n                \"LOSS\"\n            )\n        \n        self.daily_stats.pending -= 1\n        self.daily_stats.total_pnl += pnl\n        \n        # Move to completed\n        self.completed_windows.append(window)\n    \n    def update_price(self, asset: str, price: float):\n        \"\"\"Update price and check for arbitrage opportunities\"\"\"\n        # Store price\n        self.prices[asset].append({\n            'timestamp': datetime.now(),\n            'price': price\n        })\n        \n        # Get current window\n        window = self.current_windows.get(asset)\n        \n        # Check if we need a new window\n        if not window or datetime.now() >= window.end_time:\n            # Resolve ending window\n            if window:\n                self._resolve_window(window, price)\n            \n            # Create new window\n            window = self._create_new_window(asset, price)\n            self.current_windows[asset] = window\n            self.log(\n                f\"{asset} - New window started at ${price:,.2f} | \"\n                f\"Market: {window.market_slug or 'NOT FOUND'}\",\n                \"WINDOW\"\n            )\n        \n        # Update current price\n        window.current_price = price\n        \n        # Check for arbitrage opportunity\n        if window.can_trade and self._check_safety_limits():\n            signal = self._detect_arbitrage(window)\n            if signal:\n                self._execute_arbitrage(signal, window)\n    \n    # =========================================================================\n    # ARBITRAGE DETECTION\n    # =========================================================================\n    \n    def _detect_arbitrage(self, window: ArbitrageWindow) -> Optional[ArbitrageSignal]:\n        \"\"\"\n        Detect if there's an arbitrage opportunity.\n        \n        Key insight: We're not predicting where price WILL go.\n        We're observing where price HAS gone (on Binance) and betting\n        that Polymarket's Chainlink-based settlement will follow.\n        \"\"\"\n        if not window.start_price or not window.current_price:\n            return None\n        \n        price_change = window.price_change_pct\n        \n        # Need significant move to have an edge\n        if abs(price_change) < MIN_PRICE_MOVE:\n            return None\n        \n        # Determine direction based on price movement\n        direction = \"UP\" if price_change > 0 else \"DOWN\"\n        \n        # Skip if we already traded this direction\n        if window.traded and window.trade_direction == direction:\n            return None\n        \n        # =====================================================================\n        # CALCULATE BASE CONFIDENCE (the arbitrage edge)\n        # =====================================================================\n        \n        # 1. Magnitude of move (bigger move = stronger signal)\n        #    Scale: 0.3% = 50%, 0.5% = 75%, 1%+ = 100%\n        magnitude_score = min(abs(price_change) / 0.006, 1.0)  # Full score at 0.6%\n        \n        # 2. Timing within window (earlier = better for arbitrage)\n        #    In the first 5 minutes, the market hasn't fully priced in the move\n        #    Early (0-2 min) = higher edge, Late (4-5 min) = lower edge\n        time_ratio = window.seconds_elapsed / MAX_TRADE_WINDOW\n        timing_score = 1.0 - (time_ratio * 0.5)  # 100% at 0s, 50% at 5min\n        \n        # 3. Momentum check (is the move continuing or reversing?)\n        #    Recent 30 seconds vs previous 30 seconds\n        momentum_score = self._calculate_momentum(window.asset, direction)\n        \n        # Combine scores (weighted)\n        base_confidence = (\n            magnitude_score * 0.50 +    # 50% weight on move size\n            timing_score * 0.30 +       # 30% weight on timing\n            momentum_score * 0.20       # 20% weight on momentum\n        )\n        \n        # =====================================================================\n        # APPLY LEARNING ADJUSTMENTS\n        # =====================================================================\n        \n        adjusted_confidence, adjustments = self.learning.get_adjusted_confidence(\n            asset=window.asset,\n            direction=direction,\n            base_confidence=base_confidence,\n            time_in_window=window.seconds_elapsed\n        )\n        \n        # Check if learning says we should skip\n        should_skip, skip_reason = self.learning.should_skip_trade(\n            asset=window.asset,\n            direction=direction,\n            adjusted_confidence=adjusted_confidence\n        )\n        \n        if should_skip:\n            return None\n        \n        # Final threshold check\n        effective_min = max(MIN_BASE_CONFIDENCE, self.learning.learned_params.min_confidence)\n        if adjusted_confidence < effective_min:\n            return None\n        \n        # Build reason string\n        reason = (\n            f\"Binance {direction} {abs(price_change)*100:.2f}% in {window.seconds_elapsed}s | \"\n            f\"Chainlink lag arbitrage\"\n        )\n        \n        return ArbitrageSignal(\n            asset=window.asset,\n            direction=direction,\n            base_confidence=base_confidence,\n            adjusted_confidence=adjusted_confidence,\n            price_change_pct=price_change,\n            seconds_in_window=window.seconds_elapsed,\n            window_start_price=window.start_price,\n            current_price=window.current_price,\n            reason=reason\n        )\n    \n    def _calculate_momentum(self, asset: str, direction: str) -> float:\n        \"\"\"Calculate momentum score (is move continuing or reversing?)\"\"\"\n        prices = list(self.prices[asset])\n        if len(prices) < 20:\n            return 0.5  # Neutral\n        \n        # Last 30 seconds vs previous 30 seconds\n        now = datetime.now()\n        recent = [p['price'] for p in prices if (now - p['timestamp']).total_seconds() < 30]\n        earlier = [p['price'] for p in prices if 30 <= (now - p['timestamp']).total_seconds() < 60]\n        \n        if not recent or not earlier:\n            return 0.5\n        \n        recent_avg = sum(recent) / len(recent)\n        earlier_avg = sum(earlier) / len(earlier)\n        \n        # Check if momentum matches direction\n        if direction == \"UP\" and recent_avg > earlier_avg:\n            return 0.8  # Strong momentum confirmation\n        elif direction == \"DOWN\" and recent_avg < earlier_avg:\n            return 0.8\n        elif direction == \"UP\" and recent_avg < earlier_avg:\n            return 0.3  # Momentum reversing\n        elif direction == \"DOWN\" and recent_avg > earlier_avg:\n            return 0.3\n        \n        return 0.5  # Neutral\n    \n    # =========================================================================\n    # TRADE EXECUTION\n    # =========================================================================\n    \n    def _execute_arbitrage(self, signal: ArbitrageSignal, window: ArbitrageWindow):\n        \"\"\"Execute an arbitrage trade\"\"\"\n        \n        # Update window state\n        window.traded = True\n        window.trade_direction = signal.direction\n        window.last_trade_time = datetime.now()\n        \n        # Log the arbitrage opportunity\n        self.log(\n            f\"{signal.asset} - ARBITRAGE DETECTED: {signal.direction} | \"\n            f\"Price Î”: {signal.price_change_pct*100:+.2f}% | \"\n            f\"Base conf: {signal.base_confidence:.0%} â†’ Adj: {signal.adjusted_confidence:.0%} | \"\n            f\"Window: {signal.seconds_in_window}s/{MAX_TRADE_WINDOW}s\",\n            \"ARBITRAGE\"\n        )\n        \n        # Execute via CLOB\n        result = self.executor.place_order(\n            market_slug=window.market_slug,\n            direction=signal.direction,\n            size_usd=POSITION_SIZE,\n            order_type=\"MARKET\"\n        )\n        \n        if not result.success:\n            self.log(f\"Execution failed: {result.error}\", \"ERROR\")\n            window.traded = False  # Allow retry\n            return\n        \n        # Record in learning engine\n        trade_id = self.learning.record_trade(\n            asset=signal.asset,\n            direction=signal.direction,\n            confidence=signal.adjusted_confidence,\n            price_at_entry=signal.current_price,\n            price_change_at_entry=signal.price_change_pct,\n            time_in_window=signal.seconds_in_window,\n            window_start_price=signal.window_start_price,\n            order_id=result.order_id,\n            market_slug=window.market_slug\n        )\n        \n        # Track for resolution\n        self.pending_trades[window.market_slug] = {\n            'trade_id': trade_id,\n            'direction': signal.direction,\n            'window_start_price': window.start_price,\n            'entry_price': result.price,\n            'size': result.size,\n            'order_id': result.order_id\n        }\n        \n        # Update stats\n        self.daily_stats.total_trades += 1\n        self.daily_stats.pending += 1\n        \n        # Log execution\n        mode_str = \"ðŸ“ PAPER\" if PAPER_TRADING else \"ðŸ’¸ LIVE\"\n        self.log(\n            f\"{mode_str} - Executed: {signal.direction} {signal.asset} | \"\n            f\"${POSITION_SIZE:.2f} @ {result.price:.4f} ({result.size:.2f} shares) | \"\n            f\"Order: {result.order_id}\",\n            \"EXECUTE\"\n        )\n    \n    # =========================================================================\n    # WEBSOCKET & MAIN LOOP\n    # =========================================================================\n    \n    async def binance_websocket(self, asset: str):\n        \"\"\"Monitor Binance WebSocket for real-time prices\"\"\"\n        url = self.ws_urls[asset]\n        \n        while self.running:\n            try:\n                async with websockets.connect(url) as ws:\n                    self.log(f\"Connected to Binance {asset} WebSocket\", \"INFO\")\n                    \n                    while self.running:\n                        msg = await ws.recv()\n                        data = json.loads(msg)\n                        price = float(data['p'])\n                        self.update_price(asset, price)\n                        \n            except Exception as e:\n                self.log(f\"WebSocket error for {asset}: {e}\", \"ERROR\")\n                await asyncio.sleep(5)\n    \n    async def status_reporter(self):\n        \"\"\"Report status periodically\"\"\"\n        while self.running:\n            await asyncio.sleep(120)  # Every 2 minutes\n            \n            # Get learning stats\n            lp = self.learning.learned_params\n            overall = self.learning._get_overall_stats()\n            \n            # Current windows info\n            btc_window = self.current_windows.get('BTC')\n            eth_window = self.current_windows.get('ETH')\n            \n            status = [\n                \"\",\n                \"=\" * 60,\n                \"ðŸ“Š ARBITRAGE LEARNER STATUS\",\n                \"=\" * 60,\n                f\"Mode: {'ðŸ“ PAPER' if PAPER_TRADING else 'ðŸ’¸ LIVE'} | State: {'ðŸ›‘ PAUSED' if self.paused else 'âœ… ACTIVE'}\",\n                \"\",\n                \"ðŸ’° TODAY\",\n                f\"   Trades: {self.daily_stats.total_trades} | Pending: {self.daily_stats.pending}\",\n                f\"   W/L: {self.daily_stats.wins}/{self.daily_stats.losses}\",\n                f\"   P&L: ${self.daily_stats.total_pnl:.2f}\",\n                f\"   Consecutive losses: {self.daily_stats.consecutive_losses}\",\n                \"\",\n                \"ðŸ§  LEARNING ENGINE\",\n                f\"   Historical: {overall['total']} trades | {overall['win_rate']:.0%} WR\",\n                f\"   Total P&L: ${overall['total_pnl']:.2f}\",\n                f\"   Min confidence: {lp.min_confidence:.0%}\",\n            ]\n            \n            if btc_window:\n                status.append(\"\")\n                status.append(\"ðŸ“ˆ CURRENT WINDOWS\")\n                status.append(\n                    f\"   BTC: ${btc_window.current_price:,.2f} | \"\n                    f\"Î”: {btc_window.price_change_pct*100:+.2f}% | \"\n                    f\"Elapsed: {btc_window.seconds_elapsed}s | \"\n                    f\"{'âœ… Traded' if btc_window.traded else 'â³ Watching'}\"\n                )\n            \n            if eth_window:\n                status.append(\n                    f\"   ETH: ${eth_window.current_price:,.2f} | \"\n                    f\"Î”: {eth_window.price_change_pct*100:+.2f}% | \"\n                    f\"Elapsed: {eth_window.seconds_elapsed}s | \"\n                    f\"{'âœ… Traded' if eth_window.traded else 'â³ Watching'}\"\n                )\n            \n            status.append(\"=\" * 60)\n            self.log(\"\\n\".join(status))\n    \n    async def run(self):\n        \"\"\"Main run loop\"\"\"\n        self.running = True\n        \n        # Get learning stats\n        lp = self.learning.learned_params\n        overall = self.learning._get_overall_stats()\n        \n        import sys\n        def p(msg): print(msg, flush=True)\n        \n        p(\"\\n\" + \"=\" * 70)\n        p(\"ðŸ’Ž POLYMARKET ARBITRAGE LEARNER BOT\")\n        p(\"=\" * 70)\n        p(\"\")\n        p(\"ðŸ“‹ STRATEGY:\")\n        p(\"   â€¢ Monitor Binance for real-time BTC/ETH prices\")\n        p(\"   â€¢ Detect significant moves (0.3%+) in first 5 min of window\")\n        p(\"   â€¢ Execute on Polymarket BEFORE odds adjust (Chainlink lag)\")\n        p(\"   â€¢ Market settles based on Chainlink â†’ profit from the lag\")\n        p(\"\")\n        p(\"âš™ï¸  CONFIGURATION:\")\n        p(f\"   Mode: {'ðŸ“ PAPER TRADING' if PAPER_TRADING else 'ðŸ’¸ LIVE TRADING'}\")\n        p(f\"   Position size: ${POSITION_SIZE:.2f}\")\n        p(f\"   Min price move: {MIN_PRICE_MOVE*100:.1f}%\")\n        p(f\"   Trade window: First {MAX_TRADE_WINDOW}s of 15-min markets\")\n        p(f\"   Wallet: {WALLET_ADDRESS}\")\n        p(\"\")\n        p(\"ðŸ§  LEARNING ENGINE:\")\n        p(f\"   Historical trades: {overall['total']}\")\n        if overall['total'] > 0:\n            p(f\"   Historical win rate: {overall['win_rate']:.1%}\")\n            p(f\"   Historical P&L: ${overall['total_pnl']:.2f}\")\n        p(f\"   Learned min confidence: {lp.min_confidence:.0%}\")\n        p(f\"   Params version: v{lp.version}\")\n        p(\"\")\n        p(\"=\" * 70)\n        p(\"ðŸš€ Starting...\")\n        p(\"\")\n        \n        try:\n            tasks = [\n                self.binance_websocket('BTC'),\n                self.binance_websocket('ETH'),\n                self.status_reporter()\n            ]\n            await asyncio.gather(*tasks)\n            \n        except KeyboardInterrupt:\n            self.log(\"Shutting down...\", \"INFO\")\n            self.running = False\n        finally:\n            self._print_summary()\n    \n    def _print_summary(self):\n        \"\"\"Print final summary\"\"\"\n        print(\"\\n\" + \"=\" * 70)\n        print(\"ðŸ“Š SESSION SUMMARY\")\n        print(\"=\" * 70)\n        print(f\"   Total trades: {self.daily_stats.total_trades}\")\n        print(f\"   Wins: {self.daily_stats.wins}\")\n        print(f\"   Losses: {self.daily_stats.losses}\")\n        print(f\"   Pending: {self.daily_stats.pending}\")\n        if self.daily_stats.wins + self.daily_stats.losses > 0:\n            wr = self.daily_stats.wins / (self.daily_stats.wins + self.daily_stats.losses)\n            print(f\"   Win rate: {wr:.1%}\")\n        print(f\"   Total P&L: ${self.daily_stats.total_pnl:.2f}\")\n        print(\"=\" * 70)\n        \n        # Print learning report\n        print()\n        print(self.learning.get_performance_report())\n\n# ============================================================================\n# MAIN\n# ============================================================================\n\nasync def main():\n    bot = ArbitrageLearnerBot()\n    await bot.run()\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"\\nðŸ‘‹ Stopped by user\")\n"
}
