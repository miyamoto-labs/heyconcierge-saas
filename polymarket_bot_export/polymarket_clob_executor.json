{
  "filename": "polymarket_clob_executor.py",
  "description": "Order execution - handles CLOB API and EIP-712 signing",
  "bugs_found": [
    "Line 285: exec_price = book['best_ask'] - No price targeting, takes any price",
    "Should reject trades where best_ask > 0.65 for favorable risk/reward"
  ],
  "code": "#!/usr/bin/env python3\n\"\"\"\nProduction Polymarket CLOB Executor\nProper EIP-712 signing implementation using official Polymarket libraries\n\"\"\"\n\nimport sys\nimport os\nimport time\nimport json\nimport hashlib\nimport hmac\nimport requests\nfrom typing import Dict, Optional, Tuple\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom eth_account import Account\nfrom eth_utils import keccak\nfrom decimal import Decimal, ROUND_DOWN\n\n# Add the local repos to Python path\nsys.path.insert(0, '/Users/erik/.openclaw/workspace/py-clob-client')\nsys.path.insert(0, '/Users/erik/.openclaw/workspace/python-order-utils')\nsys.path.insert(0, '/Users/erik/.openclaw/workspace/poly-py-eip712-structs')\n\n# Import Polymarket libraries\nfrom py_clob_client.client import ClobClient\nfrom py_clob_client.clob_types import (\n    OrderArgs,\n    MarketOrderArgs,\n    OrderType,\n    ApiCreds,\n    PartialCreateOrderOptions\n)\nfrom py_clob_client.order_builder.constants import BUY, SELL\n\n# ============================================================================\n# CONFIGURATION\n# ============================================================================\n\nCLOB_HOST = \"https://clob.polymarket.com\"\nCHAIN_ID = 137  # Polygon mainnet\nGAMMA_API = \"https://gamma-api.polymarket.com\"\n\n# Erik's wallet\nPRIVATE_KEY = \"0x4badb53d27e3a1142c4bb509e4d00a64645401359a69afc928246666a2edac36\"\nWALLET_ADDRESS = \"0x114B7A51A4cF04897434408bd9003626705a2208\"\n\n# Trading parameters\nMIN_ORDER_SIZE_USD = 1.0\nMAX_ORDER_SIZE_USD = 20.0\n\n# ============================================================================\n# POLYMARKET CLOB EXECUTOR\n# ============================================================================\n\n@dataclass\nclass TradeResult:\n    \"\"\"Result of a trade execution\"\"\"\n    success: bool\n    order_id: Optional[str] = None\n    tx_hash: Optional[str] = None\n    error: Optional[str] = None\n    price: Optional[float] = None\n    size: Optional[float] = None\n\nclass PolymarketExecutor:\n    \"\"\"\n    Production-ready Polymarket order executor\n    Implements proper EIP-712 signing using official Polymarket libraries\n    \"\"\"\n    \n    def __init__(self, private_key: str, wallet_address: str, paper_mode: bool = True):\n        self.private_key = private_key\n        self.wallet_address = wallet_address\n        self.paper_mode = paper_mode\n        \n        self.client = None\n        self.creds = None\n        \n        self._token_cache = {}\n        self._orderbook_cache = {}\n        self._last_cache_clear = time.time()\n        \n        if not paper_mode:\n            self._initialize_client()\n    \n    def _initialize_client(self):\n        \"\"\"Initialize authenticated CLOB client\"\"\"\n        try:\n            print(\"üîê Initializing Polymarket CLOB client...\")\n            \n            self.client = ClobClient(\n                host=CLOB_HOST,\n                chain_id=CHAIN_ID,\n                key=self.private_key,\n                signature_type=0,\n                funder=self.wallet_address\n            )\n            \n            print(f\"‚úÖ Client address: {self.client.get_address()}\")\n            \n            print(\"üîë Creating API credentials...\")\n            self.creds = self.client.create_or_derive_api_creds()\n            self.client.set_api_creds(self.creds)\n            \n            print(f\"‚úÖ API Key: {self.creds.api_key[:16]}...\")\n            print(\"‚úÖ CLOB client fully authenticated (Level 2)\")\n            \n            server_time = self.client.get_server_time()\n            print(f\"‚úÖ Server connection verified. Time: {server_time}\")\n            \n            return True\n            \n        except Exception as e:\n            print(f\"‚ùå Failed to initialize CLOB client: {e}\")\n            import traceback\n            traceback.print_exc()\n            return False\n    \n    def _clear_cache_if_needed(self):\n        if time.time() - self._last_cache_clear > 300:\n            self._token_cache.clear()\n            self._orderbook_cache.clear()\n            self._last_cache_clear = time.time()\n    \n    def get_market_tokens(self, market_slug: str) -> Tuple[Optional[str], Optional[str]]:\n        self._clear_cache_if_needed()\n        \n        if market_slug in self._token_cache:\n            return self._token_cache[market_slug]\n        \n        try:\n            url = f\"{GAMMA_API}/events\"\n            response = requests.get(url, params={\"slug\": market_slug}, timeout=5)\n            \n            if response.status_code == 200:\n                events = response.json()\n                if events and len(events) > 0:\n                    event = events[0]\n                    markets = event.get('markets', [])\n                    if markets:\n                        market = markets[0]\n                        clob_tokens_str = market.get('clobTokenIds')\n                        if clob_tokens_str:\n                            if clob_tokens_str.startswith('['):\n                                clob_tokens = json.loads(clob_tokens_str)\n                            else:\n                                clob_tokens = [t.strip().strip('\"') for t in clob_tokens_str.split(',')]\n                            if len(clob_tokens) >= 2:\n                                yes_token = clob_tokens[0]\n                                no_token = clob_tokens[1]\n                                self._token_cache[market_slug] = (yes_token, no_token)\n                                print(f\"‚úÖ Found market via events: {market_slug}\")\n                                return yes_token, no_token\n            \n            url = f\"{GAMMA_API}/markets\"\n            response = requests.get(url, params={\"slug\": market_slug}, timeout=5)\n            \n            if response.status_code == 200:\n                markets = response.json()\n                if markets and len(markets) > 0:\n                    market = markets[0]\n                    clob_tokens_str = market.get('clobTokenIds')\n                    if clob_tokens_str:\n                        clob_tokens = json.loads(clob_tokens_str)\n                        if len(clob_tokens) >= 2:\n                            yes_token = clob_tokens[0]\n                            no_token = clob_tokens[1]\n                            self._token_cache[market_slug] = (yes_token, no_token)\n                            return yes_token, no_token\n                    \n                    tokens = market.get('tokens', [])\n                    if len(tokens) >= 2:\n                        yes_token = tokens[0].get('token_id')\n                        no_token = tokens[1].get('token_id')\n                        self._token_cache[market_slug] = (yes_token, no_token)\n                        return yes_token, no_token\n            \n            print(f\"‚ö†Ô∏è Market not found: {market_slug}\")\n            return None, None\n            \n        except Exception as e:\n            print(f\"‚ö†Ô∏è Error fetching market tokens: {e}\")\n            import traceback\n            traceback.print_exc()\n            return None, None\n    \n    def get_orderbook(self, token_id: str) -> Optional[Dict]:\n        try:\n            cache_key = f\"{token_id}_{int(time.time() // 10)}\"\n            \n            if cache_key in self._orderbook_cache:\n                return self._orderbook_cache[cache_key]\n            \n            if self.paper_mode:\n                url = f\"{CLOB_HOST}/book\"\n                response = requests.get(url, params={\"token_id\": token_id}, timeout=5)\n                \n                if response.status_code == 200:\n                    book = response.json()\n                    bids = book.get(\"bids\", [])\n                    asks = book.get(\"asks\", [])\n                    \n                    best_bid = float(bids[0][\"price\"]) if bids else 0.0\n                    best_ask = float(asks[0][\"price\"]) if asks else 1.0\n                    \n                    result = {\n                        \"best_bid\": best_bid,\n                        \"best_ask\": best_ask,\n                        \"spread\": best_ask - best_bid,\n                        \"bid_size\": float(bids[0][\"size\"]) if bids else 0.0,\n                        \"ask_size\": float(asks[0][\"size\"]) if asks else 0.0\n                    }\n                    \n                    self._orderbook_cache[cache_key] = result\n                    return result\n            else:\n                book = self.client.get_order_book(token_id)\n                best_bid = float(book.bids[0].price) if book.bids else 0.0\n                best_ask = float(book.asks[0].price) if book.asks else 1.0\n                \n                result = {\n                    \"best_bid\": best_bid,\n                    \"best_ask\": best_ask,\n                    \"spread\": best_ask - best_bid,\n                    \"bid_size\": float(book.bids[0].size) if book.bids else 0.0,\n                    \"ask_size\": float(book.asks[0].size) if book.asks else 0.0\n                }\n                \n                self._orderbook_cache[cache_key] = result\n                return result\n            \n        except Exception as e:\n            print(f\"‚ö†Ô∏è Error fetching orderbook: {e}\")\n            return None\n    \n    def place_order(\n        self,\n        market_slug: str,\n        direction: str,\n        size_usd: float,\n        order_type: str = \"MARKET\",\n        limit_price: Optional[float] = None\n    ) -> TradeResult:\n        \n        if size_usd < MIN_ORDER_SIZE_USD:\n            return TradeResult(\n                success=False,\n                error=f\"Order size too small: ${size_usd:.2f} < ${MIN_ORDER_SIZE_USD:.2f}\"\n            )\n        \n        if size_usd > MAX_ORDER_SIZE_USD:\n            return TradeResult(\n                success=False,\n                error=f\"Order size too large: ${size_usd:.2f} > ${MAX_ORDER_SIZE_USD:.2f}\"\n            )\n        \n        if direction not in [\"UP\", \"DOWN\"]:\n            return TradeResult(success=False, error=f\"Invalid direction: {direction}\")\n        \n        yes_token, no_token = self.get_market_tokens(market_slug)\n        if not yes_token or not no_token:\n            return TradeResult(success=False, error=f\"Market not found: {market_slug}\")\n        \n        token_id = yes_token if direction == \"UP\" else no_token\n        side = BUY\n        \n        print(f\"\\n{'='*70}\")\n        print(f\"üìä PLACING ORDER\")\n        print(f\"{'='*70}\")\n        print(f\"Market: {market_slug}\")\n        print(f\"Direction: {direction}\")\n        print(f\"Token ID: {token_id}\")\n        print(f\"Size: ${size_usd:.2f}\")\n        print(f\"Type: {order_type}\")\n        print(f\"Mode: {'üìù PAPER' if self.paper_mode else 'üí∏ LIVE'}\")\n        \n        try:\n            book = self.get_orderbook(token_id)\n            if not book:\n                return TradeResult(success=False, error=\"Failed to fetch orderbook\")\n            \n            print(f\"\\nüìñ Orderbook:\")\n            print(f\"   Best Bid: {book['best_bid']:.4f}\")\n            print(f\"   Best Ask: {book['best_ask']:.4f}\")\n            print(f\"   Spread: {book['spread']:.4f}\")\n            \n            if order_type == \"MARKET\":\n                return self._place_market_order(token_id, side, size_usd, book)\n            else:\n                return self._place_limit_order(token_id, side, size_usd, limit_price, book)\n        \n        except Exception as e:\n            print(f\"\\n‚ùå Order execution failed: {e}\")\n            import traceback\n            traceback.print_exc()\n            return TradeResult(success=False, error=str(e))\n    \n    def _place_market_order(\n        self,\n        token_id: str,\n        side: str,\n        amount_usd: float,\n        book: Dict\n    ) -> TradeResult:\n        \n        exec_price = book['best_ask']\n        shares = amount_usd / exec_price\n        \n        print(f\"\\n‚ö° Market Order:\")\n        print(f\"   Amount: ${amount_usd:.2f}\")\n        print(f\"   Execution Price: {exec_price:.4f}\")\n        print(f\"   Shares: {shares:.2f}\")\n        \n        if self.paper_mode:\n            order_id = f\"PAPER_{int(time.time())}_{token_id[:8]}\"\n            print(f\"\\n‚úÖ PAPER MODE: Order simulated successfully\")\n            print(f\"   Order ID: {order_id}\")\n            \n            return TradeResult(\n                success=True,\n                order_id=order_id,\n                price=exec_price,\n                size=shares\n            )\n        else:\n            print(f\"\\nüí∏ EXECUTING LIVE ORDER...\")\n            \n            order_args = MarketOrderArgs(\n                token_id=token_id,\n                amount=amount_usd,\n                side=side,\n                order_type=OrderType.FOK,\n                fee_rate_bps=0\n            )\n            \n            signed_order = self.client.create_market_order(order_args)\n            \n            print(f\"‚úÖ Order created and signed (EIP-712)\")\n            if hasattr(signed_order, 'order'):\n                print(f\"   Order: {signed_order.order}\")\n            else:\n                print(f\"   Signed order: {type(signed_order)}\")\n            \n            response = self.client.post_order(signed_order, OrderType.FOK)\n            \n            order_id = response.get(\"orderID\")\n            \n            print(f\"\\n‚úÖ ORDER EXECUTED SUCCESSFULLY!\")\n            print(f\"   Order ID: {order_id}\")\n            print(f\"   Status: {response.get('status', 'LIVE')}\")\n            \n            return TradeResult(\n                success=True,\n                order_id=order_id,\n                price=exec_price,\n                size=shares,\n                tx_hash=response.get(\"transactionHash\")\n            )\n    \n    def _place_limit_order(\n        self,\n        token_id: str,\n        side: str,\n        size_usd: float,\n        limit_price: float,\n        book: Dict\n    ) -> TradeResult:\n        \n        if limit_price is None or limit_price <= 0 or limit_price >= 1:\n            return TradeResult(success=False, error=\"Invalid limit price (must be 0 < price < 1)\")\n        \n        shares = size_usd / limit_price\n        \n        print(f\"\\nüìã Limit Order:\")\n        print(f\"   Price: {limit_price:.4f}\")\n        print(f\"   Size: {shares:.2f} shares\")\n        print(f\"   Total: ${size_usd:.2f}\")\n        \n        if self.paper_mode:\n            order_id = f\"PAPER_LIMIT_{int(time.time())}_{token_id[:8]}\"\n            print(f\"\\n‚úÖ PAPER MODE: Limit order simulated\")\n            print(f\"   Order ID: {order_id}\")\n            \n            return TradeResult(\n                success=True,\n                order_id=order_id,\n                price=limit_price,\n                size=shares\n            )\n        else:\n            print(f\"\\nüí∏ EXECUTING LIVE LIMIT ORDER...\")\n            \n            order_args = OrderArgs(\n                token_id=token_id,\n                price=limit_price,\n                size=shares,\n                side=side,\n                fee_rate_bps=0\n            )\n            \n            signed_order = self.client.create_order(order_args)\n            \n            print(f\"‚úÖ Limit order created and signed (EIP-712)\")\n            \n            response = self.client.post_order(signed_order, OrderType.GTC)\n            \n            order_id = response.get(\"orderID\")\n            \n            print(f\"\\n‚úÖ LIMIT ORDER PLACED!\")\n            print(f\"   Order ID: {order_id}\")\n            print(f\"   Status: OPEN (waiting for fill)\")\n            \n            return TradeResult(\n                success=True,\n                order_id=order_id,\n                price=limit_price,\n                size=shares\n            )\n    \n    def get_open_orders(self) -> list:\n        if self.paper_mode:\n            print(\"üìù Paper mode: No real orders to fetch\")\n            return []\n        \n        try:\n            orders = self.client.get_orders()\n            print(f\"üìä Found {len(orders)} open orders\")\n            return orders\n        except Exception as e:\n            print(f\"‚ùå Error fetching orders: {e}\")\n            return []\n    \n    def cancel_order(self, order_id: str) -> bool:\n        if self.paper_mode:\n            print(f\"üìù Paper mode: Simulated cancel of {order_id}\")\n            return True\n        \n        try:\n            self.client.cancel(order_id)\n            print(f\"‚úÖ Order cancelled: {order_id}\")\n            return True\n        except Exception as e:\n            print(f\"‚ùå Failed to cancel order: {e}\")\n            return False\n    \n    def get_balance(self) -> Dict:\n        if self.paper_mode:\n            return {\"usdc\": 79.0, \"mode\": \"PAPER\"}\n        \n        try:\n            from py_clob_client.clob_types import BalanceAllowanceParams, AssetType\n            params = BalanceAllowanceParams(asset_type=AssetType.COLLATERAL, signature_type=0)\n            balance = self.client.get_balance_allowance(params)\n            return balance\n        except Exception as e:\n            print(f\"‚ùå Error fetching balance: {e}\")\n            return {}\n\ndef main():\n    import sys\n    paper_mode = \"--live\" not in sys.argv\n    \n    print(\"\\n\" + \"=\"*70)\n    print(\"üöÄ POLYMARKET CLOB EXECUTOR - PRODUCTION READY\")\n    print(\"=\"*70)\n    print(f\"Mode: {'üìù PAPER TRADING' if paper_mode else 'üí∏ LIVE TRADING'}\")\n    print(f\"Wallet: {WALLET_ADDRESS}\")\n    print(\"=\"*70)\n    \n    executor = PolymarketExecutor(\n        private_key=PRIVATE_KEY,\n        wallet_address=WALLET_ADDRESS,\n        paper_mode=paper_mode\n    )\n    \n    print(\"\\nüîç Testing market lookup...\")\n    market_slug = \"btc-updown-15m-1738857600\"\n    yes_token, no_token = executor.get_market_tokens(market_slug)\n    \n    if yes_token and no_token:\n        print(f\"‚úÖ Market found!\")\n        print(f\"   YES token: {yes_token}\")\n        print(f\"   NO token: {no_token}\")\n        \n        book = executor.get_orderbook(yes_token)\n        if book:\n            print(f\"\\nüìñ Orderbook:\")\n            print(f\"   Best Bid: {book['best_bid']:.4f}\")\n            print(f\"   Best Ask: {book['best_ask']:.4f}\")\n            print(f\"   Spread: {book['spread']:.4f}\")\n    \n    if \"--test\" in sys.argv:\n        print(\"\\nüß™ Testing order placement...\")\n        result = executor.place_order(\n            market_slug=market_slug,\n            direction=\"UP\",\n            size_usd=1.0,\n            order_type=\"MARKET\"\n        )\n        \n        print(f\"\\nüìä Result:\")\n        print(f\"   Success: {result.success}\")\n        if result.success:\n            print(f\"   Order ID: {result.order_id}\")\n            print(f\"   Price: {result.price:.4f}\")\n            print(f\"   Shares: {result.size:.2f}\")\n        else:\n            print(f\"   Error: {result.error}\")\n    \n    print(\"\\n\" + \"=\"*70)\n    print(\"‚úÖ Executor ready for integration!\")\n    print(\"=\"*70 + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n"
}
