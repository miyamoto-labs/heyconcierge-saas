{
  "filename": "polymarket_learning.py",
  "description": "Adaptive learning engine - tracks trades and adjusts parameters",
  "bugs_found": [
    "Lines 214-221: Hardcoded P&L values assume 0.50 odds",
    "trade.pnl = 4.50 for win - should be calculated based on actual entry price",
    "trade.pnl = -5.00 for loss - should be -stake (the position size)"
  ],
  "code": "#!/usr/bin/env python3\n\"\"\"\nPolymarket Adaptive Learning Engine\nMakes the trading bot genuinely smarter with each trade.\n\"\"\"\n\nimport json\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass, asdict, field\nfrom collections import defaultdict\nimport statistics\n\n# ============================================================================\n# CONFIGURATION\n# ============================================================================\n\nTRADE_HISTORY_PATH = \"/Users/erik/.openclaw/workspace/trade_history.json\"\nLEARNED_PARAMS_PATH = \"/Users/erik/.openclaw/workspace/learned_params.json\"\nPERFORMANCE_STATS_PATH = \"/Users/erik/.openclaw/workspace/performance_stats.json\"\n\nTRADES_BEFORE_ADAPTATION = 20\nMIN_SAMPLES_FOR_SIGNAL = 20\nBOOST_THRESHOLD = 0.60\nREDUCE_THRESHOLD = 0.40\nMAX_CONFIDENCE_BOOST = 0.15\nMAX_CONFIDENCE_PENALTY = 0.15\nADJUSTMENT_STEP = 0.02\n\n# ============================================================================\n# DATA STRUCTURES\n# ============================================================================\n\n@dataclass\nclass TradeRecord:\n    id: str\n    timestamp: str\n    asset: str\n    direction: str\n    confidence: float\n    price_at_entry: float\n    price_at_resolution: Optional[float] = None\n    price_change_at_entry: float = 0.0\n    time_in_window: int = 0\n    window_start_price: float = 0.0\n    window_end_price: Optional[float] = None\n    result: str = \"PENDING\"\n    pnl: float = 0.0\n    order_id: str = \"\"\n    market_slug: str = \"\"\n    \n    @property\n    def time_bucket(self) -> str:\n        if self.time_in_window <= 180:\n            return \"early_0-3m\"\n        elif self.time_in_window <= 420:\n            return \"mid_3-7m\"\n        else:\n            return \"late_7-14m\"\n    \n    @property\n    def confidence_bucket(self) -> str:\n        if self.confidence < 0.3:\n            return \"low_<30%\"\n        elif self.confidence < 0.5:\n            return \"med_30-50%\"\n        elif self.confidence < 0.7:\n            return \"high_50-70%\"\n        else:\n            return \"very_high_>70%\"\n    \n    def to_dict(self) -> dict:\n        d = asdict(self)\n        d['time_bucket'] = self.time_bucket\n        d['confidence_bucket'] = self.confidence_bucket\n        return d\n\n@dataclass\nclass ConditionStats:\n    condition: str\n    total_trades: int = 0\n    wins: int = 0\n    losses: int = 0\n    total_pnl: float = 0.0\n    \n    @property\n    def win_rate(self) -> float:\n        if self.total_trades == 0:\n            return 0.5\n        return self.wins / self.total_trades\n    \n    @property\n    def avg_pnl(self) -> float:\n        if self.total_trades == 0:\n            return 0.0\n        return self.total_pnl / self.total_trades\n\n@dataclass\nclass LearnedParams:\n    min_confidence: float = 0.20\n    preferred_time_buckets: Dict[str, float] = field(default_factory=lambda: {\n        \"early_0-3m\": 0.0,\n        \"mid_3-7m\": 0.0,\n        \"late_7-14m\": 0.0\n    })\n    asset_modifiers: Dict[str, float] = field(default_factory=lambda: {\n        \"BTC\": 0.0,\n        \"ETH\": 0.0\n    })\n    direction_modifiers: Dict[str, float] = field(default_factory=lambda: {\n        \"UP\": 0.0,\n        \"DOWN\": 0.0\n    })\n    condition_modifiers: Dict[str, float] = field(default_factory=dict)\n    last_updated: str = \"\"\n    total_trades_analyzed: int = 0\n    version: int = 1\n\n# ============================================================================\n# LEARNING ENGINE\n# ============================================================================\n\nclass LearningEngine:\n    def __init__(self):\n        self.trade_history: List[TradeRecord] = []\n        self.learned_params = LearnedParams()\n        self.condition_stats: Dict[str, ConditionStats] = {}\n        self.trades_since_last_adaptation = 0\n        \n        self._load_trade_history()\n        self._load_learned_params()\n        self._rebuild_condition_stats()\n    \n    def log(self, msg: str, level: str = \"LEARN\"):\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        emoji = {\n            \"LEARN\": \"üß†\",\n            \"ADAPT\": \"üîß\",\n            \"BOOST\": \"‚¨ÜÔ∏è\",\n            \"REDUCE\": \"‚¨áÔ∏è\",\n            \"TRACK\": \"üìù\",\n            \"STATS\": \"üìä\"\n        }.get(level, \"üí°\")\n        print(f\"[{timestamp}] {emoji} {msg}\")\n    \n    def _load_trade_history(self):\n        if os.path.exists(TRADE_HISTORY_PATH):\n            try:\n                with open(TRADE_HISTORY_PATH, 'r') as f:\n                    data = json.load(f)\n                    self.trade_history = []\n                    for record in data.get('trades', []):\n                        record.pop('time_bucket', None)\n                        record.pop('confidence_bucket', None)\n                        self.trade_history.append(TradeRecord(**record))\n                    self.log(f\"Loaded {len(self.trade_history)} historical trades\")\n            except Exception as e:\n                self.log(f\"Error loading trade history: {e}\")\n                self.trade_history = []\n    \n    def _save_trade_history(self):\n        try:\n            data = {\n                'last_updated': datetime.now().isoformat(),\n                'total_trades': len(self.trade_history),\n                'trades': [t.to_dict() for t in self.trade_history]\n            }\n            with open(TRADE_HISTORY_PATH, 'w') as f:\n                json.dump(data, f, indent=2)\n        except Exception as e:\n            self.log(f\"Error saving trade history: {e}\")\n    \n    def _load_learned_params(self):\n        if os.path.exists(LEARNED_PARAMS_PATH):\n            try:\n                with open(LEARNED_PARAMS_PATH, 'r') as f:\n                    data = json.load(f)\n                    self.learned_params = LearnedParams(\n                        min_confidence=data.get('min_confidence', 0.20),\n                        preferred_time_buckets=data.get('preferred_time_buckets', {}),\n                        asset_modifiers=data.get('asset_modifiers', {}),\n                        direction_modifiers=data.get('direction_modifiers', {}),\n                        condition_modifiers=data.get('condition_modifiers', {}),\n                        last_updated=data.get('last_updated', ''),\n                        total_trades_analyzed=data.get('total_trades_analyzed', 0),\n                        version=data.get('version', 1)\n                    )\n                    self.log(f\"Loaded learned params (v{self.learned_params.version})\")\n            except Exception as e:\n                self.log(f\"Error loading learned params: {e}\")\n    \n    def _save_learned_params(self):\n        try:\n            self.learned_params.last_updated = datetime.now().isoformat()\n            data = asdict(self.learned_params)\n            with open(LEARNED_PARAMS_PATH, 'w') as f:\n                json.dump(data, f, indent=2)\n            self.log(f\"Saved learned params to disk\", \"ADAPT\")\n        except Exception as e:\n            self.log(f\"Error saving learned params: {e}\")\n    \n    def _save_performance_stats(self):\n        try:\n            stats = {\n                'last_updated': datetime.now().isoformat(),\n                'overall': self._get_overall_stats(),\n                'by_asset': self._get_stats_by_dimension('asset'),\n                'by_direction': self._get_stats_by_dimension('direction'),\n                'by_time_bucket': self._get_stats_by_dimension('time_bucket'),\n                'by_confidence': self._get_stats_by_dimension('confidence_bucket'),\n                'rolling_24h': self._get_rolling_stats(hours=24),\n                'rolling_7d': self._get_rolling_stats(hours=168),\n                'condition_combos': {k: asdict(v) for k, v in self.condition_stats.items()}\n            }\n            with open(PERFORMANCE_STATS_PATH, 'w') as f:\n                json.dump(stats, f, indent=2)\n        except Exception as e:\n            self.log(f\"Error saving performance stats: {e}\")\n    \n    def record_trade(self, \n                     asset: str,\n                     direction: str,\n                     confidence: float,\n                     price_at_entry: float,\n                     price_change_at_entry: float,\n                     time_in_window: int,\n                     window_start_price: float,\n                     order_id: str,\n                     market_slug: str) -> str:\n        trade_id = f\"{asset}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{len(self.trade_history)}\"\n        \n        trade = TradeRecord(\n            id=trade_id,\n            timestamp=datetime.now().isoformat(),\n            asset=asset,\n            direction=direction,\n            confidence=confidence,\n            price_at_entry=price_at_entry,\n            price_change_at_entry=price_change_at_entry,\n            time_in_window=time_in_window,\n            window_start_price=window_start_price,\n            order_id=order_id,\n            market_slug=market_slug\n        )\n        \n        self.trade_history.append(trade)\n        self.trades_since_last_adaptation += 1\n        self._save_trade_history()\n        \n        self.log(f\"Recorded trade {trade_id}: {asset} {direction} @ {confidence:.1%} confidence\", \"TRACK\")\n        \n        return trade_id\n    \n    def resolve_trade(self, trade_id: str, window_end_price: float, actual_direction: str):\n        trade = next((t for t in self.trade_history if t.id == trade_id), None)\n        if not trade:\n            self.log(f\"Trade {trade_id} not found for resolution\")\n            return\n        \n        if trade.result != \"PENDING\":\n            return\n        \n        trade.window_end_price = window_end_price\n        trade.price_at_resolution = window_end_price\n        \n        if trade.direction == actual_direction:\n            trade.result = \"WIN\"\n            trade.pnl = 4.50  # BUG: Hardcoded - should calculate based on entry price\n        else:\n            trade.result = \"LOSS\"\n            trade.pnl = -5.00  # BUG: Should be -stake\n        \n        self._save_trade_history()\n        self._update_condition_stats(trade)\n        \n        self.log(\n            f\"Resolved {trade_id}: {trade.result} | P&L: ${trade.pnl:+.2f} | \"\n            f\"{trade.asset} {trade.direction} (actual: {actual_direction})\",\n            \"WIN\" if trade.result == \"WIN\" else \"LOSS\"\n        )\n        \n        if self.trades_since_last_adaptation >= TRADES_BEFORE_ADAPTATION:\n            self._run_adaptation()\n    \n    def resolve_by_market_slug(self, market_slug: str, window_end_price: float, window_start_price: float):\n        actual_direction = \"UP\" if window_end_price > window_start_price else \"DOWN\"\n        \n        pending_trades = [\n            t for t in self.trade_history \n            if t.market_slug == market_slug and t.result == \"PENDING\"\n        ]\n        \n        for trade in pending_trades:\n            self.resolve_trade(trade.id, window_end_price, actual_direction)\n    \n    def _rebuild_condition_stats(self):\n        self.condition_stats = {}\n        resolved_trades = [t for t in self.trade_history if t.result in (\"WIN\", \"LOSS\")]\n        for trade in resolved_trades:\n            self._update_condition_stats(trade, save=False)\n    \n    def _update_condition_stats(self, trade: TradeRecord, save: bool = True):\n        if trade.result not in (\"WIN\", \"LOSS\"):\n            return\n        \n        is_win = trade.result == \"WIN\"\n        \n        conditions = [\n            f\"asset:{trade.asset}\",\n            f\"direction:{trade.direction}\",\n            f\"time:{trade.time_bucket}\",\n            f\"confidence:{trade.confidence_bucket}\",\n        ]\n        \n        combos = [\n            f\"asset:{trade.asset}|direction:{trade.direction}\",\n            f\"asset:{trade.asset}|time:{trade.time_bucket}\",\n            f\"direction:{trade.direction}|time:{trade.time_bucket}\",\n            f\"asset:{trade.asset}|confidence:{trade.confidence_bucket}\",\n        ]\n        \n        all_conditions = conditions + combos\n        \n        for cond in all_conditions:\n            if cond not in self.condition_stats:\n                self.condition_stats[cond] = ConditionStats(condition=cond)\n            \n            stats = self.condition_stats[cond]\n            stats.total_trades += 1\n            if is_win:\n                stats.wins += 1\n            else:\n                stats.losses += 1\n            stats.total_pnl += trade.pnl\n        \n        if save:\n            self._save_performance_stats()\n    \n    def _get_overall_stats(self) -> Dict:\n        resolved = [t for t in self.trade_history if t.result in (\"WIN\", \"LOSS\")]\n        if not resolved:\n            return {'total': 0, 'wins': 0, 'losses': 0, 'win_rate': 0, 'total_pnl': 0}\n        \n        wins = sum(1 for t in resolved if t.result == \"WIN\")\n        total_pnl = sum(t.pnl for t in resolved)\n        \n        return {\n            'total': len(resolved),\n            'wins': wins,\n            'losses': len(resolved) - wins,\n            'win_rate': wins / len(resolved),\n            'total_pnl': total_pnl,\n            'avg_pnl': total_pnl / len(resolved)\n        }\n    \n    def _get_stats_by_dimension(self, dimension: str) -> Dict[str, Dict]:\n        resolved = [t for t in self.trade_history if t.result in (\"WIN\", \"LOSS\")]\n        \n        groups = defaultdict(list)\n        for trade in resolved:\n            if dimension == 'asset':\n                key = trade.asset\n            elif dimension == 'direction':\n                key = trade.direction\n            elif dimension == 'time_bucket':\n                key = trade.time_bucket\n            elif dimension == 'confidence_bucket':\n                key = trade.confidence_bucket\n            else:\n                continue\n            groups[key].append(trade)\n        \n        result = {}\n        for key, trades in groups.items():\n            wins = sum(1 for t in trades if t.result == \"WIN\")\n            total_pnl = sum(t.pnl for t in trades)\n            result[key] = {\n                'total': len(trades),\n                'wins': wins,\n                'win_rate': wins / len(trades) if trades else 0,\n                'total_pnl': total_pnl,\n                'avg_pnl': total_pnl / len(trades) if trades else 0\n            }\n        \n        return result\n    \n    def _get_rolling_stats(self, hours: int) -> Dict:\n        cutoff = datetime.now() - timedelta(hours=hours)\n        \n        resolved = [\n            t for t in self.trade_history \n            if t.result in (\"WIN\", \"LOSS\") and \n            datetime.fromisoformat(t.timestamp) >= cutoff\n        ]\n        \n        if not resolved:\n            return {'total': 0, 'wins': 0, 'win_rate': 0, 'total_pnl': 0}\n        \n        wins = sum(1 for t in resolved if t.result == \"WIN\")\n        total_pnl = sum(t.pnl for t in resolved)\n        \n        return {\n            'total': len(resolved),\n            'wins': wins,\n            'losses': len(resolved) - wins,\n            'win_rate': wins / len(resolved),\n            'total_pnl': total_pnl,\n            'avg_pnl': total_pnl / len(resolved)\n        }\n    \n    def _run_adaptation(self):\n        self.log(\"Running adaptation cycle...\", \"ADAPT\")\n        self.trades_since_last_adaptation = 0\n        \n        resolved = [t for t in self.trade_history if t.result in (\"WIN\", \"LOSS\")]\n        if len(resolved) < MIN_SAMPLES_FOR_SIGNAL:\n            self.log(f\"Only {len(resolved)} resolved trades, need {MIN_SAMPLES_FOR_SIGNAL} for adaptation\")\n            return\n        \n        adaptations_made = []\n        adaptations_made.extend(self._adapt_min_confidence())\n        adaptations_made.extend(self._adapt_time_preferences())\n        adaptations_made.extend(self._adapt_asset_preferences())\n        adaptations_made.extend(self._adapt_direction_preferences())\n        adaptations_made.extend(self._adapt_condition_combos())\n        \n        self.learned_params.version += 1\n        self.learned_params.total_trades_analyzed = len(resolved)\n        self._save_learned_params()\n        self._save_performance_stats()\n        \n        if adaptations_made:\n            self.log(f\"Adaptation complete. Changes: {', '.join(adaptations_made)}\", \"ADAPT\")\n        else:\n            self.log(\"Adaptation complete. No significant changes needed.\", \"ADAPT\")\n    \n    def _adapt_min_confidence(self) -> List[str]:\n        adaptations = []\n        conf_stats = self._get_stats_by_dimension('confidence_bucket')\n        \n        profitable_buckets = [\n            (bucket, stats) for bucket, stats in conf_stats.items()\n            if stats['total'] >= 10 and stats['win_rate'] >= 0.55\n        ]\n        \n        if not profitable_buckets:\n            if self.learned_params.min_confidence < 0.5:\n                new_min = min(self.learned_params.min_confidence + ADJUSTMENT_STEP, 0.5)\n                if new_min != self.learned_params.min_confidence:\n                    self.learned_params.min_confidence = new_min\n                    adaptations.append(f\"MIN_CONF‚Üë{new_min:.0%}\")\n        else:\n            bucket_order = [\"low_<30%\", \"med_30-50%\", \"high_50-70%\", \"very_high_>70%\"]\n            lowest_profitable = None\n            for bucket_name in bucket_order:\n                if any(b == bucket_name for b, _ in profitable_buckets):\n                    lowest_profitable = bucket_name\n                    break\n            \n            bucket_to_threshold = {\n                \"low_<30%\": 0.20,\n                \"med_30-50%\": 0.30,\n                \"high_50-70%\": 0.50,\n                \"very_high_>70%\": 0.70\n            }\n            \n            if lowest_profitable:\n                suggested_min = bucket_to_threshold.get(lowest_profitable, 0.30)\n                \n                if suggested_min < self.learned_params.min_confidence:\n                    new_min = max(\n                        self.learned_params.min_confidence - ADJUSTMENT_STEP,\n                        suggested_min\n                    )\n                    if new_min != self.learned_params.min_confidence:\n                        self.learned_params.min_confidence = new_min\n                        adaptations.append(f\"MIN_CONF‚Üì{new_min:.0%}\")\n        \n        return adaptations\n    \n    def _adapt_time_preferences(self) -> List[str]:\n        adaptations = []\n        time_stats = self._get_stats_by_dimension('time_bucket')\n        \n        for bucket, stats in time_stats.items():\n            if stats['total'] < MIN_SAMPLES_FOR_SIGNAL:\n                continue\n            \n            current_mod = self.learned_params.preferred_time_buckets.get(bucket, 0.0)\n            \n            if stats['win_rate'] > BOOST_THRESHOLD:\n                new_mod = min(current_mod + ADJUSTMENT_STEP, MAX_CONFIDENCE_BOOST)\n                if new_mod != current_mod:\n                    self.learned_params.preferred_time_buckets[bucket] = new_mod\n                    adaptations.append(f\"{bucket}‚Üë\")\n            elif stats['win_rate'] < REDUCE_THRESHOLD:\n                new_mod = max(current_mod - ADJUSTMENT_STEP, -MAX_CONFIDENCE_PENALTY)\n                if new_mod != current_mod:\n                    self.learned_params.preferred_time_buckets[bucket] = new_mod\n                    adaptations.append(f\"{bucket}‚Üì\")\n        \n        return adaptations\n    \n    def _adapt_asset_preferences(self) -> List[str]:\n        adaptations = []\n        asset_stats = self._get_stats_by_dimension('asset')\n        \n        for asset, stats in asset_stats.items():\n            if stats['total'] < MIN_SAMPLES_FOR_SIGNAL:\n                continue\n            \n            current_mod = self.learned_params.asset_modifiers.get(asset, 0.0)\n            \n            if stats['win_rate'] > BOOST_THRESHOLD:\n                new_mod = min(current_mod + ADJUSTMENT_STEP, MAX_CONFIDENCE_BOOST)\n                if new_mod != current_mod:\n                    self.learned_params.asset_modifiers[asset] = new_mod\n                    adaptations.append(f\"{asset}‚Üë\")\n            elif stats['win_rate'] < REDUCE_THRESHOLD:\n                new_mod = max(current_mod - ADJUSTMENT_STEP, -MAX_CONFIDENCE_PENALTY)\n                if new_mod != current_mod:\n                    self.learned_params.asset_modifiers[asset] = new_mod\n                    adaptations.append(f\"{asset}‚Üì\")\n        \n        return adaptations\n    \n    def _adapt_direction_preferences(self) -> List[str]:\n        adaptations = []\n        dir_stats = self._get_stats_by_dimension('direction')\n        \n        for direction, stats in dir_stats.items():\n            if stats['total'] < MIN_SAMPLES_FOR_SIGNAL:\n                continue\n            \n            current_mod = self.learned_params.direction_modifiers.get(direction, 0.0)\n            \n            if stats['win_rate'] > BOOST_THRESHOLD:\n                new_mod = min(current_mod + ADJUSTMENT_STEP, MAX_CONFIDENCE_BOOST)\n                if new_mod != current_mod:\n                    self.learned_params.direction_modifiers[direction] = new_mod\n                    adaptations.append(f\"{direction}‚Üë\")\n            elif stats['win_rate'] < REDUCE_THRESHOLD:\n                new_mod = max(current_mod - ADJUSTMENT_STEP, -MAX_CONFIDENCE_PENALTY)\n                if new_mod != current_mod:\n                    self.learned_params.direction_modifiers[direction] = new_mod\n                    adaptations.append(f\"{direction}‚Üì\")\n        \n        return adaptations\n    \n    def _adapt_condition_combos(self) -> List[str]:\n        adaptations = []\n        \n        for condition, stats in self.condition_stats.items():\n            if stats.total_trades < MIN_SAMPLES_FOR_SIGNAL:\n                continue\n            \n            if '|' not in condition:\n                continue\n            \n            current_mod = self.learned_params.condition_modifiers.get(condition, 0.0)\n            \n            if stats.win_rate > BOOST_THRESHOLD:\n                new_mod = min(current_mod + ADJUSTMENT_STEP, MAX_CONFIDENCE_BOOST)\n                if new_mod != current_mod:\n                    self.learned_params.condition_modifiers[condition] = new_mod\n                    adaptations.append(f\"combo:{condition[:20]}‚Üë\")\n            elif stats.win_rate < REDUCE_THRESHOLD:\n                new_mod = max(current_mod - ADJUSTMENT_STEP, -MAX_CONFIDENCE_PENALTY)\n                if new_mod != current_mod:\n                    self.learned_params.condition_modifiers[condition] = new_mod\n                    adaptations.append(f\"combo:{condition[:20]}‚Üì\")\n        \n        return adaptations\n    \n    def get_adjusted_confidence(self, \n                                asset: str, \n                                direction: str, \n                                base_confidence: float,\n                                time_in_window: int) -> Tuple[float, Dict[str, float]]:\n        adjustments = {}\n        \n        if time_in_window <= 180:\n            time_bucket = \"early_0-3m\"\n        elif time_in_window <= 420:\n            time_bucket = \"mid_3-7m\"\n        else:\n            time_bucket = \"late_7-14m\"\n        \n        asset_mod = self.learned_params.asset_modifiers.get(asset, 0.0)\n        if asset_mod != 0:\n            adjustments[f'asset:{asset}'] = asset_mod\n        \n        dir_mod = self.learned_params.direction_modifiers.get(direction, 0.0)\n        if dir_mod != 0:\n            adjustments[f'direction:{direction}'] = dir_mod\n        \n        time_mod = self.learned_params.preferred_time_buckets.get(time_bucket, 0.0)\n        if time_mod != 0:\n            adjustments[f'time:{time_bucket}'] = time_mod\n        \n        combos_to_check = [\n            f\"asset:{asset}|direction:{direction}\",\n            f\"asset:{asset}|time:{time_bucket}\",\n            f\"direction:{direction}|time:{time_bucket}\",\n        ]\n        \n        for combo in combos_to_check:\n            combo_mod = self.learned_params.condition_modifiers.get(combo, 0.0)\n            if combo_mod != 0:\n                adjustments[f'combo:{combo}'] = combo_mod\n        \n        total_adjustment = sum(adjustments.values())\n        adjusted_confidence = base_confidence + total_adjustment\n        adjusted_confidence = max(0.0, min(1.0, adjusted_confidence))\n        \n        return adjusted_confidence, adjustments\n    \n    def should_skip_trade(self, \n                          asset: str, \n                          direction: str, \n                          adjusted_confidence: float) -> Tuple[bool, str]:\n        if adjusted_confidence < self.learned_params.min_confidence:\n            return True, f\"Below min confidence ({self.learned_params.min_confidence:.0%})\"\n        \n        combo = f\"asset:{asset}|direction:{direction}\"\n        if combo in self.learned_params.condition_modifiers:\n            if self.learned_params.condition_modifiers[combo] <= -0.10:\n                return True, f\"Poor historical performance for {combo}\"\n        \n        return False, \"\"\n    \n    def get_performance_report(self) -> str:\n        overall = self._get_overall_stats()\n        rolling_24h = self._get_rolling_stats(24)\n        rolling_7d = self._get_rolling_stats(168)\n        \n        asset_stats = self._get_stats_by_dimension('asset')\n        dir_stats = self._get_stats_by_dimension('direction')\n        time_stats = self._get_stats_by_dimension('time_bucket')\n        \n        lines = [\n            \"=\" * 60,\n            \"üß† LEARNING ENGINE PERFORMANCE REPORT\",\n            \"=\" * 60,\n            \"\",\n            \"üìä OVERALL STATS\",\n            f\"   Total trades: {overall['total']}\",\n            f\"   Win rate: {overall['win_rate']:.1%}\",\n            f\"   Total P&L: ${overall['total_pnl']:.2f}\",\n            \"\",\n            \"üìà ROLLING STATS\",\n            f\"   24h: {rolling_24h['total']} trades, {rolling_24h['win_rate']:.1%} WR, ${rolling_24h['total_pnl']:.2f}\",\n            f\"   7d:  {rolling_7d['total']} trades, {rolling_7d['win_rate']:.1%} WR, ${rolling_7d['total_pnl']:.2f}\",\n            \"\",\n            \"ü™ô BY ASSET\",\n        ]\n        \n        for asset, stats in asset_stats.items():\n            mod = self.learned_params.asset_modifiers.get(asset, 0)\n            mod_str = f\" ({mod:+.0%})\" if mod != 0 else \"\"\n            lines.append(f\"   {asset}: {stats['win_rate']:.1%} WR ({stats['total']} trades){mod_str}\")\n        \n        lines.extend([\n            \"\",\n            \"‚¨ÜÔ∏è BY DIRECTION\",\n        ])\n        \n        for direction, stats in dir_stats.items():\n            mod = self.learned_params.direction_modifiers.get(direction, 0)\n            mod_str = f\" ({mod:+.0%})\" if mod != 0 else \"\"\n            lines.append(f\"   {direction}: {stats['win_rate']:.1%} WR ({stats['total']} trades){mod_str}\")\n        \n        lines.extend([\n            \"\",\n            \"‚è±Ô∏è BY TIME BUCKET\",\n        ])\n        \n        for bucket, stats in time_stats.items():\n            mod = self.learned_params.preferred_time_buckets.get(bucket, 0)\n            mod_str = f\" ({mod:+.0%})\" if mod != 0 else \"\"\n            lines.append(f\"   {bucket}: {stats['win_rate']:.1%} WR ({stats['total']} trades){mod_str}\")\n        \n        lines.extend([\n            \"\",\n            \"üîß LEARNED PARAMETERS\",\n            f\"   Min confidence: {self.learned_params.min_confidence:.0%}\",\n            f\"   Version: {self.learned_params.version}\",\n            f\"   Last updated: {self.learned_params.last_updated}\",\n            \"=\" * 60,\n        ])\n        \n        return \"\\n\".join(lines)\n\nif __name__ == \"__main__\":\n    engine = LearningEngine()\n    print(engine.get_performance_report())\n"
}
